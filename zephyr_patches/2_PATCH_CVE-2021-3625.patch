diff --git a/samples/net/wpanusb/src/wpanusb.c b/samples/net/wpanusb/src/wpanusb.c
index 6cd7e00365..5545ec2cca 100644
--- a/samples/net/wpanusb/src/wpanusb.c
+++ b/samples/net/wpanusb/src/wpanusb.c
@@ -133,6 +133,9 @@ static int wpanusb_vendor_handler(struct usb_setup_packet *setup,
 {
 	struct net_pkt *pkt;
 
+	if (usb_reqtype_is_to_host(setup)) {
+		return -ENOTSUP;
+	}
 	/* Maximum 2 bytes are added to the len */
 	pkt = net_pkt_alloc_with_buffer(NULL, *len + 2, AF_UNSPEC, 0,
 					K_NO_WAIT);
diff --git a/samples/subsys/usb/webusb/src/main.c b/samples/subsys/usb/webusb/src/main.c
index 6ca9dbb9c4..a07c78f098 100644
--- a/samples/subsys/usb/webusb/src/main.c
+++ b/samples/subsys/usb/webusb/src/main.c
@@ -213,6 +213,9 @@ static const uint8_t msos1_compatid_descriptor[] = {
 int custom_handle_req(struct usb_setup_packet *pSetup,
 		      int32_t *len, uint8_t **data)
 {
+	if (usb_reqtype_is_to_device(pSetup)) {
+		return -ENOTSUP;
+	}
 	if (GET_DESC_TYPE(pSetup->wValue) == USB_STRING_DESC &&
 	    GET_DESC_INDEX(pSetup->wValue) == 0xEE) {
 		*data = (uint8_t *)(&msos1_string_descriptor);
@@ -239,6 +242,9 @@ int custom_handle_req(struct usb_setup_packet *pSetup,
 int vendor_handle_req(struct usb_setup_packet *pSetup,
 		      int32_t *len, uint8_t **data)
 {
+	if (usb_reqtype_is_to_device(pSetup)) {
+		return -ENOTSUP;
+	}
 	/* Get Allowed origins request */
 	if (pSetup->bRequest == 0x01 && pSetup->wIndex == 0x01) {
 		*data = (uint8_t *)(&webusb_allowed_origins);
diff --git a/subsys/usb/class/audio/audio.c b/subsys/usb/class/audio/audio.c
index ad78118fe5..c1e2c7f57f 100644
--- a/subsys/usb/class/audio/audio.c
+++ b/subsys/usb/class/audio/audio.c
@@ -498,7 +498,7 @@ static struct usb_audio_dev_data *get_audio_dev_data_by_iface(uint8_t interface)
  * This function handles feature unit mute control request.
  *
  * @param audio_dev_data USB audio device data.
- * @param pSetup	 Information about the executed request.
+ * @param setup	 Information about the executed request.
  * @param len		 Size of the buffer.
  * @param data		 Buffer containing the request result.
  * @param evt		 Feature Unit Event info.
@@ -508,34 +508,37 @@ static struct usb_audio_dev_data *get_audio_dev_data_by_iface(uint8_t interface)
  * @return 0 if succesfulf, negative errno otherwise.
  */
 static int handle_fu_mute_req(struct usb_audio_dev_data *audio_dev_data,
-			      struct usb_setup_packet *pSetup,
+			      struct usb_setup_packet *setup,
 			      int32_t *len, uint8_t **data,
 			      struct usb_audio_fu_evt *evt,
 			      uint8_t device)
 {
-	uint8_t ch = (pSetup->wValue) & 0xFF;
+	uint8_t ch = (setup->wValue) & 0xFF;
 	uint8_t ch_cnt = audio_dev_data->ch_cnt[device];
 	uint8_t *controls = audio_dev_data->controls[device];
 	uint8_t *control_val = &controls[POS(MUTE, ch, ch_cnt)];
 
-	/* Check if *len has valid value */
-	if (*len != LEN(1, MUTE)) {
-		return -EINVAL;
-	}
+	if (usb_reqtype_is_to_device(setup)) {
+		/* Check if *len has valid value */
+		if (*len != LEN(1, MUTE)) {
+			return -EINVAL;
+		}
 
-	switch (pSetup->bRequest) {
-	case USB_AUDIO_SET_CUR:
-		evt->val = control_val;
-		evt->val_len = *len;
-		memcpy(control_val, *data, *len);
-		return 0;
-	case USB_AUDIO_GET_CUR:
-		*data = control_val;
-		return 0;
-	default:
-		break;
+		if (setup->bRequest == USB_AUDIO_SET_CUR) {
+			evt->val = control_val;
+			evt->val_len = *len;
+			memcpy(control_val, *data, *len);
+			return 0;
+		}
+	} else {
+		if (setup->bRequest == USB_AUDIO_GET_CUR) {
+			*data = control_val;
+			*len = LEN(1, MUTE);
+			return 0;
+		}
 	}
 
+
 	return -EINVAL;
 }
 
@@ -598,7 +601,8 @@ static int handle_feature_unit_req(struct usb_audio_dev_data *audio_dev_data,
 
 	/* Inform the app */
 	if (audio_dev_data->ops && audio_dev_data->ops->feature_update_cb) {
-		if (pSetup->bRequest == USB_AUDIO_SET_CUR) {
+		if (usb_reqtype_is_to_device(pSetup) &&
+		    pSetup->bRequest == USB_AUDIO_SET_CUR) {
 			evt.cs = cs;
 			evt.channel = ch;
 			evt.dir = get_fu_dir(fu);
@@ -689,6 +693,11 @@ static int audio_custom_handler(struct usb_setup_packet *pSetup, int32_t *len,
 
 	uint8_t iface = (pSetup->wIndex) & 0xFF;
 
+	if (pSetup->RequestType.recipient != USB_REQTYPE_RECIPIENT_INTERFACE ||
+	    usb_reqtype_is_to_host(pSetup)) {
+		return -EINVAL;
+	}
+
 	audio_dev_data = get_audio_dev_data_by_iface(iface);
 	if (audio_dev_data == NULL) {
 		return -EINVAL;
diff --git a/subsys/usb/class/bluetooth.c b/subsys/usb/class/bluetooth.c
index 173f35e48f..ece9a02d65 100644
--- a/subsys/usb/class/bluetooth.c
+++ b/subsys/usb/class/bluetooth.c
@@ -376,6 +376,11 @@ static int bluetooth_class_handler(struct usb_setup_packet *setup,
 {
 	struct net_buf *buf;
 
+	if (usb_reqtype_is_to_host(setup) ||
+	    setup->RequestType.type != USB_REQTYPE_TYPE_CLASS) {
+		return -ENOTSUP;
+	}
+
 	LOG_DBG("len %u", *len);
 
 	buf = bt_buf_get_tx(BT_BUF_CMD, K_NO_WAIT, *data, *len);
diff --git a/subsys/usb/class/bt_h4.c b/subsys/usb/class/bt_h4.c
index 6995f5ea6d..7199b2574c 100644
--- a/subsys/usb/class/bt_h4.c
+++ b/subsys/usb/class/bt_h4.c
@@ -200,25 +200,6 @@ static void bt_h4_status_cb(struct usb_cfg_data *cfg,
 static int bt_h4_vendor_handler(struct usb_setup_packet *setup,
 				int32_t *len, uint8_t **data)
 {
-	LOG_DBG("Class request: bRequest 0x%x bmRequestType 0x%x len %d",
-		setup->bRequest, setup->bmRequestType, *len);
-
-	if (REQTYPE_GET_RECIP(setup->bmRequestType) != REQTYPE_RECIP_DEVICE) {
-		return -ENOTSUP;
-	}
-
-	if (REQTYPE_GET_DIR(setup->bmRequestType) == REQTYPE_DIR_TO_DEVICE &&
-	    setup->bRequest == 0x5b) {
-		LOG_DBG("Host-to-Device, data %p", *data);
-		return 0;
-	}
-
-	if ((REQTYPE_GET_DIR(setup->bmRequestType) == REQTYPE_DIR_TO_HOST) &&
-	    (setup->bRequest == 0x5c)) {
-		LOG_DBG("Device-to-Host, wLength %d, data %p",
-			setup->wLength, *data);
-		return 0;
-	}
 
 	return -ENOTSUP;
 }
diff --git a/subsys/usb/class/cdc_acm.c b/subsys/usb/class/cdc_acm.c
index 621f433152..efad8b4452 100644
--- a/subsys/usb/class/cdc_acm.c
+++ b/subsys/usb/class/cdc_acm.c
@@ -209,13 +209,13 @@ static const struct uart_driver_api cdc_acm_driver_api;
 /**
  * @brief Handler called for Class requests not handled by the USB stack.
  *
- * @param pSetup    Information about the request to execute.
+ * @param setup    Information about the request to execute.
  * @param len       Size of the buffer.
  * @param data      Buffer containing the request result.
  *
  * @return  0 on success, negative errno code on fail.
  */
-int cdc_acm_class_handle_req(struct usb_setup_packet *pSetup,
+int cdc_acm_class_handle_req(struct usb_setup_packet *setup,
 			     int32_t *len, uint8_t **data)
 {
 	struct cdc_acm_dev_data_t *dev_data;
@@ -224,56 +224,58 @@ int cdc_acm_class_handle_req(struct usb_setup_packet *pSetup,
 	uint32_t new_rate;
 
 	common = usb_get_dev_data_by_iface(&cdc_acm_data_devlist,
-					   (uint8_t)pSetup->wIndex);
+					   (uint8_t)setup->wIndex);
 	if (common == NULL) {
 		LOG_WRN("Device data not found for interface %u",
-			pSetup->wIndex);
+			setup->wIndex);
 		return -ENODEV;
 	}
 
 	dev_data = CONTAINER_OF(common, struct cdc_acm_dev_data_t, common);
 
-	switch (pSetup->bRequest) {
+	if (usb_reqtype_is_to_device(setup)) {
+		switch (setup->bRequest) {
 	case SET_LINE_CODING:
-		rate = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
-		memcpy(&dev_data->line_coding,
-		       *data, sizeof(dev_data->line_coding));
-		new_rate = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
-		LOG_DBG("CDC_SET_LINE_CODING %d %d %d %d",
-			new_rate,
-			dev_data->line_coding.bCharFormat,
-			dev_data->line_coding.bParityType,
-			dev_data->line_coding.bDataBits);
+			rate = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
+			memcpy(&dev_data->line_coding, *data,
+			       sizeof(dev_data->line_coding));
+			new_rate = sys_le32_to_cpu(dev_data->line_coding.dwDTERate);
+			LOG_DBG("CDC_SET_LINE_CODING %d %d %d %d",
+				new_rate,
+				dev_data->line_coding.bCharFormat,
+				dev_data->line_coding.bParityType,
+				dev_data->line_coding.bDataBits);
 #if defined(CONFIG_CDC_ACM_DTE_RATE_CALLBACK_SUPPORT)
-		if (rate != new_rate && dev_data->rate_cb != NULL) {
-			dev_data->rate_cb(common->dev, new_rate);
-		}
+			if (rate != new_rate && dev_data->rate_cb != NULL) {
+				dev_data->rate_cb(common->dev, new_rate);
+			}
 #endif
-		break;
-
+		return 0;
 	case SET_CONTROL_LINE_STATE:
-		dev_data->line_state = (uint8_t)pSetup->wValue;
-		LOG_DBG("CDC_SET_CONTROL_LINE_STATE 0x%x",
-			dev_data->line_state);
-		break;
-
-	case GET_LINE_CODING:
-		*data = (uint8_t *)(&dev_data->line_coding);
-		*len = sizeof(dev_data->line_coding);
-		LOG_DBG("CDC_GET_LINE_CODING %d %d %d %d",
-			sys_le32_to_cpu(dev_data->line_coding.dwDTERate),
-			dev_data->line_coding.bCharFormat,
-			dev_data->line_coding.bParityType,
-			dev_data->line_coding.bDataBits);
-		break;
+			dev_data->line_state = (uint8_t)setup->wValue;
+			LOG_DBG("CDC_SET_CONTROL_LINE_STATE 0x%x",
+				dev_data->line_state);
+			return 0;
 
 	default:
-		LOG_DBG("CDC ACM request 0x%x, value 0x%x",
-			pSetup->bRequest, pSetup->wValue);
-		return -EINVAL;
+			break;
+		}
+	} else {
+		if (setup->bRequest == GET_LINE_CODING) {
+			*data = (uint8_t *)(&dev_data->line_coding);
+			*len = sizeof(dev_data->line_coding);
+			LOG_DBG("CDC_GET_LINE_CODING %d %d %d %d",
+				sys_le32_to_cpu(dev_data->line_coding.dwDTERate),
+				dev_data->line_coding.bCharFormat,
+				dev_data->line_coding.bParityType,
+				dev_data->line_coding.bDataBits);
+			return 0;
+		}
 	}
-
-	return 0;
+	
+	LOG_DBG("CDC ACM bmRequestType 0x%02x bRequest 0x%02x unsupported",
+		setup->bmRequestType, setup->bRequest);
+	return -ENOTSUP;
 }
 
 static void cdc_acm_write_cb(uint8_t ep, int size, void *priv)
diff --git a/subsys/usb/class/dfu/usb_dfu.c b/subsys/usb/class/dfu/usb_dfu.c
index c86bc42d9b..89a49c1921 100644
--- a/subsys/usb/class/dfu/usb_dfu.c
+++ b/subsys/usb/class/dfu/usb_dfu.c
@@ -387,24 +387,14 @@ static void dfu_timer_expired(struct k_timer *timer)
 		dfu_data.state = appIDLE;
 	}
 }
-
-/**
- * @brief Handler called for DFU Class requests not handled by the USB stack.
- *
- * @param pSetup    Information about the request to execute.
- * @param len       Size of the buffer.
- * @param data      Buffer containing the request result.
- *
- * @return  0 on success, negative errno code on fail.
- */
-static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
-		int32_t *data_len, uint8_t **data)
+static int dfu_class_handle_to_host(struct usb_setup_packet *setup,
+				    int32_t *data_len, uint8_t **data)
 {
+	uint32_t bytes_left;
+	uint32_t len;
 	int ret;
-	uint32_t len, bytes_left;
-	uint16_t timeout;
 
-	switch (pSetup->bRequest) {
+	switch (setup->bRequest) {
 	case DFU_GETSTATUS:
 		LOG_DBG("DFU_GETSTATUS: status %d, state %d",
 			dfu_data.status, dfu_data.state);
@@ -431,68 +421,15 @@ static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
 		*data_len = 1;
 		break;
 
-	case DFU_ABORT:
-		LOG_DBG("DFU_ABORT");
-
-		if (dfu_check_app_state()) {
-			return -EINVAL;
-		}
-
-		dfu_reset_counters();
-		dfu_data.state = dfuIDLE;
-		dfu_data.status = statusOK;
-		break;
-
-	case DFU_CLRSTATUS:
-		LOG_DBG("DFU_CLRSTATUS");
-
-		if (dfu_check_app_state()) {
-			return -EINVAL;
-		}
-
-		dfu_data.state = dfuIDLE;
-		dfu_data.status = statusOK;
-		break;
-
-	case DFU_DNLOAD:
-		LOG_DBG("DFU_DNLOAD block %d, len %d, state %d",
-			pSetup->wValue, pSetup->wLength, dfu_data.state);
-
-		if (dfu_check_app_state()) {
-			return -EINVAL;
-		}
-
-		switch (dfu_data.state) {
-		case dfuIDLE:
-			LOG_DBG("DFU_DNLOAD start");
-			dfu_reset_counters();
-			k_poll_signal_reset(&dfu_signal);
-
-			dfu_data.state = dfuDNBUSY;
-			dfu_data_worker.worker_state = dfuIDLE;
-			dfu_data_worker.worker_len  = pSetup->wLength;
-			memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
-			k_work_submit_to_queue(&USB_WORK_Q, &dfu_work);
-			break;
-		case dfuDNLOAD_IDLE:
-			dfu_data.state = dfuDNBUSY;
-			dfu_data_worker.worker_state = dfuDNLOAD_IDLE;
-			dfu_data_worker.worker_len  = pSetup->wLength;
-
-			memcpy(dfu_data_worker.buf, *data, pSetup->wLength);
-			k_work_submit_to_queue(&USB_WORK_Q, &dfu_work);
-			break;
-		default:
-			LOG_ERR("DFU_DNLOAD wrong state %d", dfu_data.state);
-			dfu_data.state = dfuERROR;
-			dfu_data.status = errUNKNOWN;
-			dfu_reset_counters();
-			return -EINVAL;
-		}
-		break;
 	case DFU_UPLOAD:
 		LOG_DBG("DFU_UPLOAD block %d, len %d, state %d",
-			pSetup->wValue, pSetup->wLength, dfu_data.state);
+			setup->wValue, setup->wLength, dfu_data.state);
+		if (!IS_ENABLED(CONFIG_USB_DFU_ENABLE_UPLOAD)) {
+			LOG_WRN("Firmware uploading is not enabled");
+			dfu_data.status = errSTALLEDPKT;
+			dfu_data.state = dfuERROR;
+			return -ENOTSUP;
+		}
 
 		if (dfu_check_app_state()) {
 			return -EINVAL;
@@ -503,23 +440,23 @@ static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
 			dfu_reset_counters();
 			LOG_DBG("DFU_UPLOAD start");
 		case dfuUPLOAD_IDLE:
-			if (!pSetup->wLength ||
+			if (!setup->wLength ||
 			    dfu_data.block_nr != pSetup->wValue) {
-				LOG_DBG("DFU_UPLOAD block %d, expected %d, "
-					"len %d", pSetup->wValue,
-					dfu_data.block_nr, pSetup->wLength);
+				LOG_ERR("DFU_UPLOAD block %d, expected %d, "
+					"len %d", setup->wValue,
+					dfu_data.block_nr, setup->wLength);
 				dfu_data.state = dfuERROR;
 				dfu_data.status = errUNKNOWN;
-				break;
+				return -EINVAL;
 			}
 
 			/* Upload in progress */
 			bytes_left = dfu_data.flash_upload_size -
 				     dfu_data.bytes_sent;
-			if (bytes_left < pSetup->wLength) {
+			if (bytes_left < setup->wLength) {
 				len = bytes_left;
 			} else {
-				len = pSetup->wLength;
+				len = setup->wLength;
 			}
 
 			if (len > USB_DFU_MAX_XFER_SIZE) {
@@ -539,7 +476,7 @@ static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
 				if (ret) {
 					dfu_data.state = dfuERROR;
 					dfu_data.status = errFILE;
-					break;
+					return -EINVAL;
 				}
 				ret = flash_area_read(fa, dfu_data.bytes_sent,
 						      *data, len);
@@ -547,7 +484,7 @@ static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
 				if (ret) {
 					dfu_data.state = dfuERROR;
 					dfu_data.status = errFILE;
-					break;
+					return -EINVAL;
 				}
 			}
 			*data_len = len;
@@ -556,18 +493,99 @@ static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
 			dfu_data.block_nr++;
 
 			if (dfu_data.bytes_sent == dfu_data.flash_upload_size &&
-			    len < pSetup->wLength) {
+			    len < setup->wLength) {
 				/* Upload completed when a
 				 * short packet is received
 				 */
 				*data_len = 0;
 				dfu_data.state = dfuIDLE;
-			} else
+			} else {
 				dfu_data.state = dfuUPLOAD_IDLE;
+			} break;
+		default:
+			LOG_ERR("DFU_UPLOAD wrong state %d", dfu_data.state);
+			dfu_data.state = dfuERROR;
+			dfu_data.status = errUNKNOWN;
+			dfu_reset_counters();
+			return -EINVAL;
+		}
+		break;
+
+	default:
+		LOG_DBG("Unsupported bmRequestType 0x%02x bRequest 0x%02x",
+			setup->bmRequestType, setup->bRequest);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int dfu_class_handle_to_device(struct usb_setup_packet *setup,
+				      int32_t *data_len, uint8_t **data)
+{
+	uint16_t timeout;
+
+	switch (setup->bRequest) {
+	case DFU_ABORT:
+		LOG_DBG("DFU_ABORT");
+
+		if (dfu_check_app_state()) {
+			return -EINVAL;
+		}
+
+		dfu_reset_counters();
+		dfu_data.state = dfuIDLE;
+		dfu_data.status = statusOK;
+		break;
+
+	case DFU_CLRSTATUS:
+		LOG_DBG("DFU_CLRSTATUS");
+
+		if (dfu_check_app_state()) {
+			return -EINVAL;
+		}
+
+		dfu_data.state = dfuIDLE;
+		dfu_data.status = statusOK;
+		break;
+
+	case DFU_DNLOAD:
+		LOG_DBG("DFU_DNLOAD block %d, len %d, state %d",
+			setup->wValue, setup->wLength, dfu_data.state);
+
+		if (dfu_check_app_state()) {
+			return -EINVAL;
+		}
+
+		switch (dfu_data.state) {
+		case dfuIDLE:
+			LOG_DBG("DFU_DNLOAD start");
+			dfu_reset_counters();
+			k_poll_signal_reset(&dfu_signal);
+
+			if (dfu_data.flash_area_id != DOWNLOAD_FLASH_AREA_ID) {
+				dfu_data.status = errWRITE;
+				dfu_data.state = dfuERROR;
+				LOG_ERR("This area can not be overwritten");
+				break;
+			}
+
+			dfu_data.state = dfuDNBUSY;
+			dfu_data_worker.worker_state = dfuIDLE;
+			dfu_data_worker.worker_len  = setup->wLength;
+			memcpy(dfu_data_worker.buf, *data, setup->wLength);
+			k_work_submit_to_queue(&USB_WORK_Q, &dfu_work);
+			break;
+		case dfuDNLOAD_IDLE:
+			dfu_data.state = dfuDNBUSY;
+			dfu_data_worker.worker_state = dfuDNLOAD_IDLE;
+			dfu_data_worker.worker_len  = setup->wLength;
 
+			memcpy(dfu_data_worker.buf, *data, setup->wLength);
+			k_work_submit_to_queue(&USB_WORK_Q, &dfu_work);
 			break;
 		default:
-			LOG_ERR("DFU_UPLOAD wrong state %d", dfu_data.state);
+			LOG_ERR("DFU_DNLOAD wrong state %d", dfu_data.state);
 			dfu_data.state = dfuERROR;
 			dfu_data.status = errUNKNOWN;
 			dfu_reset_counters();
@@ -576,7 +594,7 @@ static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
 		break;
 	case DFU_DETACH:
 		LOG_DBG("DFU_DETACH timeout %d, state %d",
-			pSetup->wValue, dfu_data.state);
+			setup->wValue, dfu_data.state);
 
 		if (dfu_data.state != appIDLE) {
 			dfu_data.state = appIDLE;
@@ -586,16 +604,35 @@ static int dfu_class_handle_req(struct usb_setup_packet *pSetup,
 		dfu_data.state = appDETACH;
 
 		/* Begin detach timeout timer */
-		timeout = MIN(pSetup->wValue, CONFIG_USB_DFU_DETACH_TIMEOUT);
+		timeout = MIN(setup->wValue, CONFIG_USB_DFU_DETACH_TIMEOUT);
 		k_timer_start(&dfu_timer, K_MSEC(timeout), K_FOREVER);
 		break;
 	default:
-		LOG_WRN("DFU UNKNOWN STATE: %d", pSetup->bRequest);
+		LOG_DBG("Unsupported bmRequestType 0x%02x bRequest 0x%02x",
+			setup->bmRequestType, setup->bRequest);
 		return -EINVAL;
 	}
 
 	return 0;
 }
+/**
+ * @brief Handler called for DFU Class requests not handled by the USB stack.
+ *
+ * @param setup     Information about the request to execute.
+ * @param len       Size of the buffer.
+ * @param data      Buffer containing the request result.
+ *
+ * @return  0 on success, negative errno code on fail.
+ */
+static int dfu_class_handle_req(struct usb_setup_packet *setup,
+				int32_t *data_len, uint8_t **data)
+{
+	if (usb_reqtype_is_to_host(setup)) {
+		return dfu_class_handle_to_host(setup, data_len, data);
+	} else {
+		return dfu_class_handle_to_device(setup, data_len, data);
+	}
+}
 
 /**
  * @brief Callback used to know the USB connection status
@@ -663,26 +700,28 @@ static void dfu_status_cb(struct usb_cfg_data *cfg,
  *        in order to catch the SET_INTERFACE request and
  *        extract the interface alternate setting
  *
- * @param pSetup    Information about the request to execute.
+ * @param setup    Information about the request to execute.
  * @param len       Size of the buffer.
  * @param data      Buffer containing the request result.
  *
- * @return  0 if SET_INTERFACE request, -ENOTSUP otherwise.
+ * @return  0  -ENOTSUP so that the stack can process control request.
  */
 
-static int dfu_custom_handle_req(struct usb_setup_packet *pSetup,
+static int dfu_custom_handle_req(struct usb_setup_packet *setup,
 		int32_t *data_len, uint8_t **data)
 {
 	ARG_UNUSED(data);
 
-	if (REQTYPE_GET_RECIP(pSetup->bmRequestType) ==
-	    REQTYPE_RECIP_INTERFACE) {
-		if (pSetup->bRequest == REQ_SET_INTERFACE) {
-			LOG_DBG("DFU alternate setting %d", pSetup->wValue);
+	if (usb_reqtype_is_to_host(setup) ||
+	    setup->RequestType.recipient != USB_REQTYPE_RECIPIENT_INTERFACE) {
+		return -ENOTSUP;
+	}
+	if (setup->bRequest == USB_SREQ_SET_INTERFACE) {
+		LOG_DBG("DFU alternate setting %d", setup->wValue);
 
-			const struct flash_area *fa;
+		const struct flash_area *fa;
 
-			switch (pSetup->wValue) {
+		switch (setup->wValue) {
 			case 0:
 				dfu_data.flash_area_id =
 				    FLASH_AREA_ID(image_0);
@@ -705,11 +744,9 @@ static int dfu_custom_handle_req(struct usb_setup_packet *pSetup,
 			dfu_data.flash_upload_size = fa->fa_size;
 			flash_area_close(fa);
 
-			dfu_data.alt_setting = pSetup->wValue;
-			*data_len = 0;
-			return 0;
+			dfu_data.alt_setting = setup->wValue;
 		}
-	}
+	
 
 	/* Not handled by us */
 	return -EINVAL;
diff --git a/subsys/usb/class/hid/core.c b/subsys/usb/class/hid/core.c
index f715689f24..a52380841c 100644
--- a/subsys/usb/class/hid/core.c
+++ b/subsys/usb/class/hid/core.c
@@ -497,7 +497,7 @@ static int hid_custom_handle_req(struct usb_setup_packet *setup,
 {
 	LOG_DBG("Standard request:"
 		"bRequest 0x%02x, bmRequestType 0x%02x, len %d",
-		setup->bRequest, setup->bmRequestType, *len);
+		setup->bRequest, setup->bmRequestType, setup->wLength);
 
 	if (REQTYPE_GET_DIR(setup->bmRequestType) == REQTYPE_DIR_TO_HOST &&
 	    REQTYPE_GET_RECIP(setup->bmRequestType) ==
@@ -526,21 +526,13 @@ static int hid_custom_handle_req(struct usb_setup_packet *setup,
 
 			LOG_DBG("Return HID Descriptor");
 
-			*len = MIN(*len, hid_desc->if0_hid.bLength);
+			*len = MIN(*setup->wLength, hid_desc->if0_hid.bLength);
 			*data = (uint8_t *)&hid_desc->if0_hid;
 			break;
 		case USB_DESC_HID_REPORT:
 			LOG_DBG("Return Report Descriptor");
 
-			/* Some buggy system may be pass a larger wLength when
-			 * it try read HID report descriptor, although we had
-			 * already tell it the right descriptor size.
-			 * So truncated wLength if it doesn't match. */
-			if (*len != dev_data->report_size) {
-				LOG_WRN("len %d doesn't match "
-					"Report Descriptor size", *len);
-				*len = MIN(*len, dev_data->report_size);
-			}
+			*len = MIN(setup->wLength, dev_data->report_size);
 			*data = (uint8_t *)dev_data->report_desc;
 			break;
 		default:
diff --git a/subsys/usb/class/loopback.c b/subsys/usb/class/loopback.c
index a49c51e691..43a9e66537 100644
--- a/subsys/usb/class/loopback.c
+++ b/subsys/usb/class/loopback.c
@@ -24,7 +24,7 @@ LOG_MODULE_REGISTER(usb_loopback);
 #define LOOPBACK_IN_EP_IDX		1
 
 static uint8_t loopback_buf[1024];
-
+BUILD_ASSERT(sizeof(loopback_buf) == CONFIG_USB_REQUEST_BUFFER_SIZE);
 /* usb.rst config structure start */
 struct usb_loopback_config {
 	struct usb_if_descriptor if0;
@@ -136,6 +136,12 @@ static int loopback_vendor_handler(struct usb_setup_packet *setup,
 	if (REQTYPE_GET_DIR(setup->bmRequestType) == REQTYPE_DIR_TO_DEVICE &&
 	    setup->bRequest == 0x5b) {
 		LOG_DBG("Host-to-Device, data %p", *data);
+		/*
+		 * Copy request data in loopback_buf buffer and reuse
+		 * it later in control device-to-host transfer.
+		 */
+		memcpy(loopback_buf, *data,
+		       MIN(sizeof(loopback_buf), setup->wLength));
 		return 0;
 	}
 
@@ -143,6 +149,8 @@ static int loopback_vendor_handler(struct usb_setup_packet *setup,
 	    (setup->bRequest == 0x5c)) {
 		LOG_DBG("Device-to-Host, wLength %d, data %p",
 			setup->wLength, *data);
+		*data = loopback_buf;
+		*len = MIN(sizeof(loopback_buf), setup->wLength);
 		return 0;
 	}
 
diff --git a/subsys/usb/class/msc.c b/subsys/usb/class/msc.c
index 62cf15d954..519ec2c643 100644
--- a/subsys/usb/class/msc.c
+++ b/subsys/usb/class/msc.c
@@ -260,47 +260,36 @@ static bool write(uint8_t *buf, uint16_t size)
  *
  * @return  0 on success, negative errno code on fail.
  */
-static int mass_storage_class_handle_req(struct usb_setup_packet *pSetup,
+static int mass_storage_class_handle_req(struct usb_setup_packet *setup,
 					 int32_t *len, uint8_t **data)
 {
-	if (pSetup->wIndex != mass_cfg.if0.bInterfaceNumber ||
-	    pSetup->wValue != 0) {
-		LOG_WRN("Invalid setup parameters");
+	if (setup->wIndex != mass_cfg.if0.bInterfaceNumber ||
+	    setup->wValue != 0) {
+		LOG_ERR("Invalid setup parameters");
 		return -EINVAL;
 	}
+		if (usb_reqtype_is_to_device(setup)) {
+			if (setup->bRequest == MSC_REQUEST_RESET &&
+			    setup->wLength == 0) {
+				LOG_DBG("MSC_REQUEST_RESET");
+				msd_state_machine_reset();
+				return 0;
+			}
 
-	switch (pSetup->bRequest) {
-	case MSC_REQUEST_RESET:
-		LOG_DBG("MSC_REQUEST_RESET");
-
-		if (pSetup->wLength) {
-			LOG_WRN("Invalid length");
-			return -EINVAL;
-		}
-
-		msd_state_machine_reset();
-		break;
-
-	case MSC_REQUEST_GET_MAX_LUN:
-		LOG_DBG("MSC_REQUEST_GET_MAX_LUN");
-
-		if (pSetup->wLength != 1) {
-			LOG_WRN("Invalid length");
-			return -EINVAL;
-		}
-
-		max_lun_count = 0U;
-		*data = (uint8_t *)(&max_lun_count);
-		*len = 1;
-		break;
-
-	default:
-		LOG_WRN("Unknown request 0x%02x, value 0x%02x",
-			pSetup->bRequest, pSetup->wValue);
-		return -EINVAL;
+		} else {
+			if (setup->bRequest == MSC_REQUEST_GET_MAX_LUN &&
+			    setup->wLength == 1) {
+			LOG_DBG("MSC_REQUEST_GET_MAX_LUN");
+			max_lun_count = 0U;
+			*data = (uint8_t *)(&max_lun_count);
+			*len = 1;
+			return 0;
+			}
 	}
 
-	return 0;
+	LOG_WRN("Unsupported bmRequestType 0x%02x bRequest 0x%02x",
+		setup->bmRequestType, setup->bRequest);
+	return -ENOTSUP;
 }
 
 static void testUnitReady(void)
diff --git a/subsys/usb/class/netusb/function_ecm.c b/subsys/usb/class/netusb/function_ecm.c
index c0d42e991d..bc2d968721 100644
--- a/subsys/usb/class/netusb/function_ecm.c
+++ b/subsys/usb/class/netusb/function_ecm.c
@@ -205,19 +205,20 @@ static int ecm_class_handler(struct usb_setup_packet *setup, int32_t *len,
 	}
 
 	if (setup->bmRequestType != USB_CDC_ECM_REQ_TYPE) {
-		LOG_WRN("Unhandled req_type 0x%x", setup->bmRequestType);
-		return 0;
+		/*
+		 * Only host-to-device, type class, recipient interface
+		 * requests are accepted.
+		 */
+		return -EINVAL;
 	}
 
-	switch (setup->bRequest) {
-	case USB_CDC_SET_ETH_PKT_FILTER:
-		LOG_DBG("intf 0x%x filter 0x%x", setup->wIndex, setup->wValue);
-		break;
-	default:
-		break;
+	if (setup->bRequest == USB_CDC_SET_ETH_PKT_FILTER) {
+		LOG_INF("Set Interface %u Packet Filter 0x%04x not supported",
+			setup->wIndex, setup->wValue);
+		return 0;
 	}
 
-	return 0;
+	return -ENOTSUP;
 }
 
 /* Retrieve expected pkt size from ethernet/ip header */
diff --git a/subsys/usb/class/netusb/function_rndis.c b/subsys/usb/class/netusb/function_rndis.c
index c8c83b8f2b..251ad19524 100644
--- a/subsys/usb/class/netusb/function_rndis.c
+++ b/subsys/usb/class/netusb/function_rndis.c
@@ -901,25 +901,23 @@ static int rndis_class_handler(struct usb_setup_packet *setup, int32_t *len,
 		LOG_ERR("interface disabled");
 		return -ENODEV;
 	}
-
-	if (setup->bRequest == CDC_SEND_ENC_CMD &&
-	    REQTYPE_GET_DIR(setup->bmRequestType) == REQTYPE_DIR_TO_DEVICE) {
-		/*
-		 * Instead of handling here, queue
-		 * handle_encapsulated_cmd(*data, *len);
-		 */
-		queue_encapsulated_cmd(*data, *len);
-	} else if (setup->bRequest == CDC_GET_ENC_RSP &&
-		   REQTYPE_GET_DIR(setup->bmRequestType) ==
-		   REQTYPE_DIR_TO_HOST) {
-		handle_encapsulated_rsp(data, len);
+	if (usb_reqtype_is_to_device(setup)) {
+		if (setup->bRequest == CDC_SEND_ENC_CMD) {
+			/*
+			 * Instead of handling here, queue
+			 * handle_encapsulated_cmd(*data, *len);
+			 */
+			return queue_encapsulated_cmd(*data, *len);
+		}
 	} else {
-		*len = 0; /* FIXME! */
-		LOG_WRN("Unknown USB packet req 0x%x type 0x%x",
-			setup->bRequest, setup->bmRequestType);
+		if (setup->bRequest == CDC_GET_ENC_RSP) {
+			return handle_encapsulated_rsp(data, len);
+		}
 	}
 
-	return 0;
+	LOG_WRN("Unknown USB packet req 0x%x type 0x%x",
+		setup->bRequest, setup->bmRequestType);
+	return -ENOTSUP;
 }
 
 static void cmd_thread(void)
