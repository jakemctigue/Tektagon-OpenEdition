diff --git a/subsys/bluetooth/host/hci_raw.c b/subsys/bluetooth/host/hci_raw.c
index 503c49e0ae..93a488fe49 100644
--- a/subsys/bluetooth/host/hci_raw.c
+++ b/subsys/bluetooth/host/hci_raw.c
@@ -159,6 +159,10 @@ struct net_buf *bt_buf_get_tx(enum bt_buf_type type, k_timeout_t timeout,
 	bt_buf_set_type(buf, type);
 
 	if (data && size) {
+		if (net_buf_tailroom(buf) < size) {
+			net_buf_unref(buf);
+			return NULL;
+		}
 		net_buf_add_mem(buf, data, size);
 	}
 
diff --git a/subsys/usb/class/bluetooth.c b/subsys/usb/class/bluetooth.c
index 173f35e48f..5484f48a75 100644
--- a/subsys/usb/class/bluetooth.c
+++ b/subsys/usb/class/bluetooth.c
@@ -226,11 +226,19 @@ static void acl_read_cb(uint8_t ep, int size, void *priv)
 		if (IS_ENABLED(CONFIG_USB_DEVICE_BLUETOOTH_VS_H4) &&
 		    bt_hci_raw_get_mode() == BT_HCI_RAW_MODE_H4) {
 			buf = bt_buf_get_tx(BT_BUF_H4, K_FOREVER, data, size);
+			if (!buf) {
+				LOG_ERR("Failed to allocate buffer");
+				goto restart_out_transfer;
+			}
 			pkt_len = hci_pkt_get_len(buf, &data[1], size - 1);
 			LOG_DBG("pkt_len %u, chunk %u", pkt_len, size);
 		} else {
 			buf = bt_buf_get_tx(BT_BUF_ACL_OUT, K_FOREVER,
 					    data, size);
+			if (!buf) {
+				LOG_ERR("Failed to allocate buffer");
+				goto restart_out_transfer;
+			}
 			pkt_len = hci_pkt_get_len(buf, data, size);
 			LOG_DBG("pkt_len %u, chunk %u", pkt_len, size);
 		}
@@ -241,6 +249,12 @@ static void acl_read_cb(uint8_t ep, int size, void *priv)
 			buf = NULL;
 		}
 	} else {
+		if (net_buf_tailroom(buf) < size) {
+			LOG_ERR("Buffer tailroom too small");
+			net_buf_unref(buf);
+			buf = NULL;
+			goto restart_out_transfer;
+		}
 		/*
 		 * Take over the next chunk if HCI packet is
 		 * larger than USB_MAX_FS_BULK_MPS.
