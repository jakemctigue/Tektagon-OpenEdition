diff --git a/drivers/can/can_loopback.c b/drivers/can/can_loopback.c
index 73c370fdda..4ce059258c 100644
--- a/drivers/can/can_loopback.c
+++ b/drivers/can/can_loopback.c
@@ -11,6 +11,8 @@
 #include "can_loopback.h"
 
 #include <logging/log.h>
+#include "can_utils.h"
+
 LOG_MODULE_DECLARE(can_driver, CONFIG_CAN_LOG_LEVEL);
 
 K_KERNEL_STACK_DEFINE(tx_thread_stack,
@@ -41,12 +43,6 @@ static void dispatch_frame(const struct zcan_frame *frame,
 	filter->rx_cb(&frame_tmp, filter->cb_arg);
 }
 
-static inline int check_filter_match(const struct zcan_frame *frame,
-				     const struct zcan_filter *filter)
-{
-	return ((filter->id & filter->id_mask) ==
-		(frame->id & filter->id_mask));
-}
 
 void tx_thread(void *data_arg, void *arg2, void *arg3)
 {
@@ -63,7 +59,7 @@ void tx_thread(void *data_arg, void *arg2, void *arg3)
 		for (int i = 0; i < CONFIG_CAN_MAX_FILTER; i++) {
 			filter = &data->filters[i];
 			if (filter->rx_cb &&
-			    check_filter_match(&frame.frame, &filter->filter)) {
+			    check_utils_filter_match(&frame.frame, &filter->filter) !=0 ) {
 				dispatch_frame(&frame.frame, filter);
 			}
 		}
diff --git a/drivers/can/can_mcan.c b/drivers/can/can_mcan.c
index 65301d529f..ba255a82db 100644
--- a/drivers/can/can_mcan.c
+++ b/drivers/can/can_mcan.c
@@ -487,6 +487,8 @@ static void can_mcan_get_message(struct can_mcan_data *data,
 	int data_length;
 	void *cb_arg;
 	struct can_mcan_rx_fifo_hdr hdr;
+	bool rtr_filter_mask;
+	bool rtr_filter;
 
 	while ((*fifo_status_reg & CAN_MCAN_RXF0S_F0FL)) {
 		get_idx = (*fifo_status_reg & CAN_MCAN_RXF0S_F0GI) >>
@@ -511,11 +513,17 @@ static void can_mcan_get_message(struct can_mcan_data *data,
 
 		filt_idx = hdr.fidx;
 
-		/* Check if RTR must match */
-		if ((hdr.xtd && data->ext_filt_rtr_mask & (1U << filt_idx) &&
-		     ((data->ext_filt_rtr >> filt_idx) & 1U) != frame.rtr) ||
-		    (data->std_filt_rtr_mask &  (1U << filt_idx) &&
-		     ((data->std_filt_rtr >> filt_idx) & 1U) != frame.rtr)) {
+		if (hdr.xtd != 0) {
+			rtr_filter_mask = (data->ext_filt_rtr_mask & BIT(filt_idx)) != 0;
+			rtr_filter = (data->ext_filt_rtr & BIT(filt_idx)) != 0;
+		} else {
+			rtr_filter_mask = (data->std_filt_rtr_mask & BIT(filt_idx)) != 0;
+			rtr_filter = (data->std_filt_rtr & BIT(filt_idx)) != 0;
+		}
+
+		if (rtr_filter_mask && (rtr_filter != frame.rtr)) {
+			/* RTR bit does not match filter RTR mask and bit, drop frame */
+			*fifo_ack_reg = get_idx;
 			continue;
 		}
 
diff --git a/drivers/can/can_mcux_flexcan.c b/drivers/can/can_mcux_flexcan.c
index ca97eca0f1..2835df2aa3 100644
--- a/drivers/can/can_mcux_flexcan.c
+++ b/drivers/can/can_mcux_flexcan.c
@@ -253,13 +253,11 @@ static void mcux_flexcan_copy_zfilter_to_mbconfig(const struct zcan_filter *src,
 	if (src->id_type == CAN_STANDARD_IDENTIFIER) {
 		dest->format = kFLEXCAN_FrameFormatStandard;
 		dest->id = FLEXCAN_ID_STD(src->id);
-		*mask = FLEXCAN_RX_MB_STD_MASK(src->id_mask,
-					       src->rtr & src->rtr_mask, 1);
+		*mask = FLEXCAN_RX_MB_STD_MASK(src->id_mask, src->rtr_mask, 1);
 	} else {
 		dest->format = kFLEXCAN_FrameFormatExtend;
 		dest->id = FLEXCAN_ID_EXT(src->id);
-		*mask = FLEXCAN_RX_MB_EXT_MASK(src->id_mask,
-					       src->rtr & src->rtr_mask, 1);
+		*mask = FLEXCAN_RX_MB_EXT_MASK(src->id_mask, src->rtr_mask, 1);
 	}
 
 	if ((src->rtr & src->rtr_mask) == CAN_DATAFRAME) {
@@ -643,32 +641,40 @@ static inline void mcux_flexcan_transfer_rx_idle(const struct device *dev,
 	}
 }
 
-static void mcux_flexcan_transfer_callback(CAN_Type *base,
-					   flexcan_handle_t *handle,
-					   status_t status, uint32_t result,
-					   void *userData)
+static FLEXCAN_CALLBACK(mcux_flexcan_transfer_callback)
 {
 	struct mcux_flexcan_data *data = (struct mcux_flexcan_data *)userData;
-
+	const struct mcux_flexcan_config *config = data->dev->config;
+	/*
+	 * The result field can either be a MB index (which is limited to 32 bit
+	 * value) or a status flags value, which is 32 bit on some platforms but
+	 * 64 on others. To decouple the remaining functions from this, the
+	 * result field is always promoted to uint64_t.
+	 */
+	uint32_t mb = (uint32_t)result;
+	uint64_t status_flags = result;
+	ARG_UNUSED(base);
 	switch (status) {
 	case kStatus_FLEXCAN_UnHandled:
+		/* Not all fault confinement state changes are handled by the HAL */
 		__fallthrough;
 	case kStatus_FLEXCAN_ErrorStatus:
-		mcux_flexcan_transfer_error_status(data->dev, result);
+		mcux_flexcan_transfer_error_status(data->dev, status_flags);
 		break;
 	case kStatus_FLEXCAN_TxSwitchToRx:
+		FLEXCAN_TransferAbortReceive(config->base, &data->handle, mb);
 		__fallthrough;
 	case kStatus_FLEXCAN_TxIdle:
-		mcux_flexcan_transfer_tx_idle(data->dev, result);
+		mcux_flexcan_transfer_tx_idle(data->dev, mb);
 		break;
 	case kStatus_FLEXCAN_RxOverflow:
 		__fallthrough;
 	case kStatus_FLEXCAN_RxIdle:
-		mcux_flexcan_transfer_rx_idle(data->dev, result);
+		mcux_flexcan_transfer_rx_idle(data->dev, mb);
 		break;
 	default:
-		LOG_WRN("Unhandled error/status (status 0x%08x, "
-			 "result = 0x%08x", status, result);
+		LOG_WRN("Unhandled status 0x%08x (result = 0x%016llx)",
+			status, status_flags);
 	}
 }
 
diff --git a/tests/drivers/can/api/src/main.c b/tests/drivers/can/api/src/main.c
index 5e65b0523c..afd138097d 100644
--- a/tests/drivers/can/api/src/main.c
+++ b/tests/drivers/can/api/src/main.c
@@ -57,7 +57,7 @@ struct k_sem rx_cb_sem;
 struct k_sem tx_cb_sem;
 const struct device *can_dev;
 
-const struct zcan_frame test_std_msg_1 = {
+const struct zcan_frame test_std_frame_1 = {
 	.id_type = CAN_STANDARD_IDENTIFIER,
 	.rtr     = CAN_DATAFRAME,
 	.id      = TEST_CAN_STD_ID_1,
@@ -65,7 +65,7 @@ const struct zcan_frame test_std_msg_1 = {
 	.data    = {1, 2, 3, 4, 5, 6, 7, 8}
 };
 
-const struct zcan_frame test_std_msg_2 = {
+const struct zcan_frame test_std_frame_2 = {
 	.id_type = CAN_STANDARD_IDENTIFIER,
 	.rtr     = CAN_DATAFRAME,
 	.id      = TEST_CAN_STD_ID_2,
@@ -73,7 +73,7 @@ const struct zcan_frame test_std_msg_2 = {
 	.data    = {1, 2, 3, 4, 5, 6, 7, 8}
 };
 
-const struct zcan_frame test_ext_msg_1 = {
+const struct zcan_frame test_ext_frame_1 = {
 	.id_type = CAN_EXTENDED_IDENTIFIER,
 	.rtr     = CAN_DATAFRAME,
 	.id      = TEST_CAN_EXT_ID_1,
@@ -89,6 +89,33 @@ const struct zcan_frame test_ext_msg_2 = {
 	.data    = {1, 2, 3, 4, 5, 6, 7, 8}
 };
 
+
+/**
+ * @brief Standard (11-bit) CAN ID RTR frame 1.
+ */
+const struct zcan_frame test_std_rtr_frame_1 = {
+	.id_type = CAN_STANDARD_IDENTIFIER,
+	.rtr     = CAN_REMOTEREQUEST,
+	.id      = TEST_CAN_STD_ID_1,
+	.dlc     = 0,
+	.data    = {0}
+};
+
+/**
+ * @brief Extended (29-bit) CAN ID RTR frame 1.
+ */
+const struct zcan_frame test_ext_rtr_frame_1 = {
+	.id_type = CAN_EXTENDED_IDENTIFIER,
+	.rtr     = CAN_REMOTEREQUEST,
+	.id      = TEST_CAN_EXT_ID_1,
+	.dlc     = 0,
+	.data    = {0}
+};
+
+/**
+ * @brief Standard (11-bit) CAN ID filter 1. This filter matches
+ * ``test_std_frame_1``.
+ */
 const struct zcan_filter test_std_filter_1 = {
 	.id_type = CAN_STANDARD_IDENTIFIER,
 	.rtr = CAN_DATAFRAME,
@@ -96,7 +123,10 @@ const struct zcan_filter test_std_filter_1 = {
 	.rtr_mask = 1,
 	.id_mask = CAN_STD_ID_MASK
 };
-
+/**
+ * @brief Standard (11-bit) CAN ID filter 2. This filter matches
+ * ``test_std_frame_2``.
+ */
 const struct zcan_filter test_std_filter_2 = {
 	.id_type = CAN_STANDARD_IDENTIFIER,
 	.rtr = CAN_DATAFRAME,
@@ -105,6 +135,10 @@ const struct zcan_filter test_std_filter_2 = {
 	.id_mask = CAN_STD_ID_MASK
 };
 
+/**
+ * @brief Standard (11-bit) CAN ID masked filter 1. This filter matches
+ * ``test_std_frame_1``.
+ */
 const struct zcan_filter test_std_masked_filter_1 = {
 	.id_type = CAN_STANDARD_IDENTIFIER,
 	.rtr = CAN_DATAFRAME,
@@ -112,16 +146,22 @@ const struct zcan_filter test_std_masked_filter_1 = {
 	.rtr_mask = 1,
 	.id_mask = TEST_CAN_STD_MASK
 };
-
+/**
+ * @brief Standard (11-bit) CAN ID masked filter 2. This filter matches
+ * ``test_std_frame_2``.
+ */
 const struct zcan_filter test_std_masked_filter_2 = {
 	.id_type = CAN_STANDARD_IDENTIFIER,
 	.rtr = CAN_DATAFRAME,
 	.id = TEST_CAN_STD_MASK_ID_2,
 	.rtr_mask = 1,
-	.id_mask = TEST_CAN_STD_MASK
+	.id_mask = TEST_CAN_EXT_MASK
 };
 
-
+/**
+ * @brief Extended (29-bit) CAN ID filter 1. This filter matches
+ * ``test_ext_frame_1``.
+ */
 const struct zcan_filter test_ext_filter_1 = {
 	.id_type = CAN_EXTENDED_IDENTIFIER,
 	.rtr = CAN_DATAFRAME,
@@ -129,7 +169,10 @@ const struct zcan_filter test_ext_filter_1 = {
 	.rtr_mask = 1,
 	.id_mask = CAN_EXT_ID_MASK
 };
-
+/**
+ * @brief Extended (29-bit) CAN ID filter 2. This filter matches
+ * ``test_ext_frame_2``.
+ */
 const struct zcan_filter test_ext_filter_2 = {
 	.id_type = CAN_EXTENDED_IDENTIFIER,
 	.rtr = CAN_DATAFRAME,
@@ -137,7 +180,10 @@ const struct zcan_filter test_ext_filter_2 = {
 	.rtr_mask = 1,
 	.id_mask = CAN_EXT_ID_MASK
 };
-
+/**
+ * @brief Extended (29-bit) CAN ID masked filter 1. This filter matches
+ * ``test_ext_frame_1``.
+ */
 const struct zcan_filter test_ext_masked_filter_1 = {
 	.id_type = CAN_EXTENDED_IDENTIFIER,
 	.rtr = CAN_DATAFRAME,
@@ -145,7 +191,10 @@ const struct zcan_filter test_ext_masked_filter_1 = {
 	.rtr_mask = 1,
 	.id_mask = TEST_CAN_EXT_MASK
 };
-
+/**
+ * @brief Extended (29-bit) CAN ID masked filter 2. This filter matches
+ * ``test_ext_frame_2``.
+ */
 const struct zcan_filter test_ext_masked_filter_2 = {
 	.id_type = CAN_EXTENDED_IDENTIFIER,
 	.rtr = CAN_DATAFRAME,
@@ -153,7 +202,34 @@ const struct zcan_filter test_ext_masked_filter_2 = {
 	.rtr_mask = 1,
 	.id_mask = TEST_CAN_EXT_MASK
 };
+/**
+ * @brief Standard (11-bit) CAN ID RTR filter 1. This filter matches
+ * ``test_std_rtr_frame_1``.
+ */
+const struct zcan_filter test_std_rtr_filter_1 = {
+	.id_type = CAN_STANDARD_IDENTIFIER,
+	.rtr = CAN_REMOTEREQUEST,
+	.id = TEST_CAN_STD_ID_1,
+	.rtr_mask = 1,
+	.id_mask = CAN_STD_ID_MASK
+};
 
+/**
+ * @brief Extended (29-bit) CAN ID RTR filter 1. This filter matches
+ * ``test_ext_rtr_frame_1``.
+ */
+const struct zcan_filter test_ext_rtr_filter_1 = {
+	.id_type = CAN_EXTENDED_IDENTIFIER,
+	.rtr = CAN_REMOTEREQUEST,
+	.id = TEST_CAN_EXT_ID_1,
+	.rtr_mask = 1,
+	.id_mask = CAN_EXT_ID_MASK
+};
+
+/**
+ * @brief Standard (11-bit) CAN ID filter. This filter matches
+ * ``TEST_CAN_SOME_STD_ID``.
+ */
 const struct zcan_filter test_std_some_filter = {
 	.id_type = CAN_STANDARD_IDENTIFIER,
 	.rtr = CAN_DATAFRAME,
@@ -162,262 +238,277 @@ const struct zcan_filter test_std_some_filter = {
 	.id_mask = CAN_STD_ID_MASK
 };
 
-struct zcan_work can_work_1;
-struct zcan_work can_work_2;
-
-static inline void check_msg(const struct zcan_frame *msg1,
-			     const struct zcan_frame *msg2,
-			     uint32_t mask)
-{
-	int cmp_res;
-	zassert_equal(msg1->id_type, msg2->id_type,
-		      "ID type does not match");
-
-	zassert_equal(msg1->rtr, msg2->rtr,
-		      "RTR bit does not match");
-
-	zassert_equal(msg1->id | mask, msg2->id | mask,
-		      "ID does not match");
-
-	zassert_equal(msg1->dlc, msg2->dlc,
-		      "DLC does not match");
-	cmp_res = memcmp(msg1->data, msg2->data, msg1->dlc);
-	zassert_equal(cmp_res, 0, "Received data differ");
-}
-
-static void tx_std_isr_1(uint32_t error_flags, void *arg)
-{
-	const struct zcan_frame *msg = (const struct zcan_frame *)arg;
-
-	k_sem_give(&tx_cb_sem);
-
-	zassert_equal(msg->id, TEST_CAN_STD_ID_1, "Arg does not match");
-}
-
-static void tx_std_isr_2(uint32_t error_flags, void *arg)
-{
-	const struct zcan_frame *msg = (const struct zcan_frame *)arg;
-
-	k_sem_give(&tx_cb_sem);
-
-	zassert_equal(msg->id, TEST_CAN_STD_ID_2, "Arg does not match");
-}
-
-static void tx_ext_isr_1(uint32_t error_flags, void *arg)
-{
-	const struct zcan_frame *msg = (const struct zcan_frame *)arg;
-
-	k_sem_give(&tx_cb_sem);
-
-	zassert_equal(msg->id, TEST_CAN_EXT_ID_1, "Arg does not match");
-}
-
-static void tx_ext_isr_2(uint32_t error_flags, void *arg)
-{
-	const struct zcan_frame *msg = (const struct zcan_frame *)arg;
-
-	k_sem_give(&tx_cb_sem);
-
-	zassert_equal(msg->id, TEST_CAN_EXT_ID_2, "Arg does not match");
-}
-
-static void rx_std_isr_1(struct zcan_frame *msg, void *arg)
-{
-	check_msg(msg, &test_std_msg_1, 0);
-	zassert_equal_ptr(arg, &test_std_filter_1, "arg does not match");
-	k_sem_give(&rx_isr_sem);
-}
-
-static void rx_std_isr_2(struct zcan_frame *msg, void *arg)
-{
-	check_msg(msg, &test_std_msg_2, 0);
-	zassert_equal_ptr(arg, &test_std_filter_2, "arg does not match");
-	k_sem_give(&rx_isr_sem);
-}
-
-static void rx_std_mask_isr_1(struct zcan_frame *msg, void *arg)
-{
-	check_msg(msg, &test_std_msg_1, 0x0F);
-	zassert_equal_ptr(arg, &test_std_masked_filter_1, "arg does not match");
-	k_sem_give(&rx_isr_sem);
-}
-
-static void rx_std_mask_isr_2(struct zcan_frame *msg, void *arg)
-{
-	check_msg(msg, &test_std_msg_2, 0x0F);
-	zassert_equal_ptr(arg, &test_std_masked_filter_2, "arg does not match");
-	k_sem_give(&rx_isr_sem);
-}
-
-static void rx_ext_isr_1(struct zcan_frame *msg, void *arg)
-{
-	check_msg(msg, &test_ext_msg_1, 0);
-	zassert_equal_ptr(arg, &test_ext_filter_1, "arg does not match");
-	k_sem_give(&rx_isr_sem);
-}
-
-static void rx_ext_isr_2(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Assert that two CAN frames are equal given a CAN ID mask.
+ *
+ * @param frame1  First CAN frame.
+ * @param frame2  Second CAN frame.
+ * @param id_mask CAN ID mask.
+ */
+static inline void assert_frame_equal(const struct zcan_frame *frame1,
+				      const struct zcan_frame *frame2,
+				      uint32_t id_mask)
+{
+	zassert_equal(frame1->id_type, frame2->id_type, "ID type does not match");
+	zassert_equal(frame1->rtr, frame2->rtr, "RTR bit does not match");
+	zassert_equal(frame1->id | id_mask, frame2->id | id_mask, "ID does not match");
+	zassert_equal(frame1->dlc, frame2->dlc, "DLC does not match");
+	zassert_mem_equal(frame1->data, frame2->data, frame1->dlc, "Received data differ");
+}
+/**
+ * @brief Standard (11-bit) CAN ID transmit callback 1.
+ *
+ * See @a can_tx_callback_t() for argument description.
+ */
+static void tx_std_callback_1(const struct device *dev, int error, void *user_data)
 {
-	check_msg(msg, &test_ext_msg_2, 0);
-	zassert_equal_ptr(arg, &test_ext_filter_2, "arg does not match");
-	k_sem_give(&rx_isr_sem);
+	const struct zcan_frame *frame = user_data;
+	k_sem_give(&tx_callback_sem);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal(frame->id, TEST_CAN_STD_ID_1, "ID does not match");
 }
-
-static void rx_ext_mask_isr_1(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Standard (11-bit) CAN ID transmit callback 2.
+ *
+ * See @a can_tx_callback_t() for argument description.
+ */
+static void tx_std_callback_2(const struct device *dev, int error, void *user_data)
 {
-	check_msg(msg, &test_ext_msg_1, 0x0F);
-	zassert_equal_ptr(arg, &test_ext_masked_filter_1, "arg does not match");
-	k_sem_give(&rx_isr_sem);
+	const struct zcan_frame *frame = user_data;
+	k_sem_give(&tx_callback_sem);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal(frame->id, TEST_CAN_STD_ID_2, "ID does not match");
 }
 
-static void rx_ext_mask_isr_2(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Extended (29-bit) CAN ID transmit callback 1.
+ *
+ * See @a can_tx_callback_t() for argument description.
+ */
+static void tx_ext_callback_1(const struct device *dev, int error, void *user_data)
 {
-	check_msg(msg, &test_ext_msg_2, 0x0F);
-	zassert_equal_ptr(arg, &test_ext_masked_filter_2, "arg does not match");
-	k_sem_give(&rx_isr_sem);
+	const struct zcan_frame *frame = user_data;
+	k_sem_give(&tx_callback_sem);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal(frame->id, TEST_CAN_EXT_ID_1, "ID does not match");
 }
-
-static void rx_std_cb_1(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Extended (29-bit) CAN ID transmit callback 2.
+ *
+ * See @a can_tx_callback_t() for argument description.
+ */
+static void tx_ext_callback_2(const struct device *dev, int error, void *user_data)
 {
-	check_msg(msg, &test_std_msg_1, 0);
-	zassert_equal_ptr(arg, &test_std_filter_1, "arg does not match");
-	k_sem_give(&rx_cb_sem);
+	const struct zcan_frame *frame = user_data;
+	k_sem_give(&tx_callback_sem);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal(frame->id, TEST_CAN_EXT_ID_2, "ID does not match");
 }
-
-static void rx_std_cb_2(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Standard (11-bit) CAN ID receive callback 1.
+ *
+ * See @a can_rx_callback_t() for argument description.
+ */
+static void rx_std_callback_1(const struct device *dev, struct zcan_frame *frame,
+			      void *user_data)
 {
-	check_msg(msg, &test_std_msg_2, 0);
-	zassert_equal_ptr(arg, &test_std_filter_2, "arg does not match");
-	k_sem_give(&rx_cb_sem);
+	struct zcan_filter *filter = user_data;
+	assert_frame_equal(frame, &test_std_frame_1, 0);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal_ptr(filter, &test_std_filter_1, "filter does not match");
+	k_sem_give(&rx_callback_sem);
 }
-
-static void rx_std_mask_cb_1(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Standard (11-bit) CAN ID receive callback 2.
+ *
+ * See @a can_rx_callback_t() for argument description.
+ */
+static void rx_std_callback_2(const struct device *dev, struct zcan_frame *frame,
+			      void *user_data)
 {
-	check_msg(msg, &test_std_msg_1, 0x0F);
-	zassert_equal_ptr(arg, &test_std_masked_filter_1, "arg does not match");
-	k_sem_give(&rx_cb_sem);
+	struct zcan_filter *filter = user_data;
+	assert_frame_equal(frame, &test_std_frame_2, 0);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal_ptr(filter, &test_std_filter_2, "filter does not match");
+	k_sem_give(&rx_callback_sem);
 }
 
-static void rx_std_mask_cb_2(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Standard (11-bit) masked CAN ID receive callback 1.
+ *
+ * See @a can_rx_callback_t() for argument description.
+ */
+static void rx_std_mask_callback_1(const struct device *dev, struct zcan_frame *frame,
+				   void *user_data)
 {
-	check_msg(msg, &test_std_msg_2, 0x0F);
-	zassert_equal_ptr(arg, &test_std_masked_filter_2, "arg does not match");
-	k_sem_give(&rx_cb_sem);
+	struct zcan_filter *filter = user_data;
+	assert_frame_equal(frame, &test_std_frame_1, 0x0F);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal_ptr(filter, &test_std_masked_filter_1, "filter does not match");
+	k_sem_give(&rx_callback_sem);
 }
-
-static void rx_ext_cb_1(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Standard (11-bit) masked CAN ID receive callback 2.
+ *
+ * See @a can_rx_callback_t() for argument description.
+ */
+static void rx_std_mask_callback_2(const struct device *dev, struct zcan_frame *frame,
+				   void *user_data)
 {
-	check_msg(msg, &test_ext_msg_1, 0);
-	zassert_equal_ptr(arg, &test_ext_filter_1, "arg does not match");
-	k_sem_give(&rx_cb_sem);
+	struct zcan_filter *filter = user_data;
+	assert_frame_equal(frame, &test_std_frame_2, 0x0F);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal_ptr(filter, &test_std_masked_filter_2, "filter does not match");
+	k_sem_give(&rx_callback_sem);
 }
-
-static void rx_ext_cb_2(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Extended (29-bit) CAN ID receive callback 1.
+ *
+ * See @a can_rx_callback_t() for argument description.
+ */
+static void rx_ext_callback_1(const struct device *dev, struct zcan_frame *frame,
+			      void *user_data)
 {
-	check_msg(msg, &test_ext_msg_2, 0);
-	zassert_equal_ptr(arg, &test_ext_filter_2, "arg does not match");
-	k_sem_give(&rx_cb_sem);
+	struct zcan_filter *filter = user_data;
+	assert_frame_equal(frame, &test_ext_frame_1, 0);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal_ptr(filter, &test_ext_filter_1, "filter does not match");
+	k_sem_give(&rx_callback_sem);
 }
-
-static void rx_ext_mask_cb_1(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Extended (29-bit) CAN ID receive callback 2.
+ *
+ * See @a can_rx_callback_t() for argument description.
+ */
+static void rx_ext_callback_2(const struct device *dev, struct zcan_frame *frame,
+			      void *user_data)
 {
-	check_msg(msg, &test_ext_msg_1, 0x0F);
-	zassert_equal_ptr(arg, &test_ext_masked_filter_1, "arg does not match");
-	k_sem_give(&rx_cb_sem);
+	struct zcan_filter *filter = user_data;
+	assert_frame_equal(frame, &test_ext_frame_2, 0);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal_ptr(filter, &test_ext_filter_2, "filter does not match");
+	k_sem_give(&rx_callback_sem);
 }
-
-static void rx_ext_mask_cb_2(struct zcan_frame *msg, void *arg)
+/**
+ * @brief Extended (29-bit) masked CAN ID receive callback 1.
+ *
+ * See @a can_rx_callback_t() for argument description.
+ */
+static void rx_ext_mask_callback_1(const struct device *dev, struct zcan_frame *frame,
+				   void *user_data)
 {
-	check_msg(msg, &test_ext_msg_2, 0x0F);
-	zassert_equal_ptr(arg, &test_ext_masked_filter_2, "arg does not match");
-	k_sem_give(&rx_cb_sem);
+	struct zcan_filter *filter = user_data;
+	assert_frame_equal(frame, &test_ext_frame_1, 0x0F);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal_ptr(filter, &test_ext_masked_filter_1, "filter does not match");
+	k_sem_give(&rx_callback_sem);
 }
-
-static void send_test_msg(const struct device *can_dev,
-			  const struct zcan_frame *msg)
+/**
+ * @brief Extended (29-bit) masked CAN ID receive callback 2.
+ *
+ * See @a can_rx_callback_t() for argument description.
+ */
+static void rx_ext_mask_callback_2(const struct device *dev, struct zcan_frame *frame,
+				   void *user_data)
 {
-	int ret;
-
-	ret = can_send(can_dev, msg, TEST_SEND_TIMEOUT, NULL, NULL);
-	zassert_not_equal(ret, CAN_TX_ARB_LOST,
-			  "Arbitration though in loopback mode");
-	zassert_equal(ret, CAN_TX_OK, "Can't send a message. Err: %d", ret);
+	struct zcan_filter *filter = user_data;
+	assert_frame_equal(frame, &test_ext_frame_2, 0x0F);
+	zassert_equal(dev, can_dev, "CAN device does not match");
+	zassert_equal_ptr(filter, &test_ext_masked_filter_2, "filter does not match");
+	k_sem_give(&rx_callback_sem);
 }
-
-static void send_test_msg_nowait(const struct device *can_dev,
-				 const struct zcan_frame *msg,
-				 can_tx_callback_t cb)
+/**
+ * @brief Send a CAN test frame with asserts.
+ *
+ * This function will block until the frame is transmitted or a test timeout
+ * occurs.
+ *
+ * @param dev   Pointer to the device structure for the driver instance.
+ * @param frame Pointer to the CAN frame to send.
+ */
+static void send_test_frame(const struct device *dev, const struct zcan_frame *frame)
 {
-	int ret;
-	ret = can_send(can_dev, msg, TEST_SEND_TIMEOUT, cb,
-			(struct zcan_frame *)msg);
-	zassert_not_equal(ret, CAN_TX_ARB_LOST,
-			  "Arbitration though in loopback mode");
-	zassert_equal(ret, CAN_TX_OK, "Can't send a message. Err: %d", ret);
+	int err;
+	err = can_send(dev, frame, TEST_SEND_TIMEOUT, NULL, NULL);
+	zassert_not_equal(err, -EBUSY, "arbitration lost in loopback mode");
+	zassert_equal(err, 0, "failed to send frame (err %d)", err);
 }
-
-static inline int attach_msgq(const struct device *can_dev,
-			      const struct zcan_filter *filter)
+/**
+ * @brief Send a CAN test frame with asserts.
+ *
+ * This function will block until the frame is queued or a test timeout
+ * occurs.
+ *
+ * @param dev      Pointer to the device structure for the driver instance.
+ * @param frame    Pointer to the CAN frame to send.
+ * @param callback Transmit callback function.
+ */
+static void send_test_frame_nowait(const struct device *dev, const struct zcan_frame *frame,
+				   can_tx_callback_t callback)
 {
-	int filter_id;
-
-	filter_id = can_attach_msgq(can_dev, &can_msgq, filter);
-	zassert_not_equal(filter_id, CAN_NO_FREE_FILTER,
-			  "Filter full even for a single one");
-	zassert_true((filter_id >= 0), "Negative filter number");
-
-	return filter_id;
+	int err;
+	err = can_send(dev, frame, TEST_SEND_TIMEOUT, callback, (void *)frame);
+	zassert_not_equal(err, -EBUSY, "arbitration lost in loopback mode");
+	zassert_equal(err, 0, "failed to send frame (err %d)", err);
 }
-
-static inline int attach_workq(const struct device *can_dev,
-			      const struct zcan_filter *filter,
-			      struct zcan_work *work,
-			      can_rx_callback_t cb)
+/**
+ * @brief Add a CAN message queue with asserts.
+ *
+ * @param dev    Pointer to the device structure for the driver instance.
+ * @param filter CAN filter for the CAN message queue.
+ *
+ * @return CAN filter ID.
+ */
+static inline int add_rx_msgq(const struct device *dev, const struct zcan_filter *filter)
 {
 	int filter_id;
-
-	filter_id  = can_attach_workq(can_dev, &k_sys_work_q, work, cb,
-				     (void *)filter, filter);
-
-	zassert_not_equal(filter_id, CAN_NO_FREE_FILTER,
-			  "Filter full even for a single one");
-	zassert_true((filter_id >= 0), "Negative filter number");
-
+	filter_id = can_add_rx_filter_msgq(dev, &can_msgq, filter);
+	zassert_not_equal(filter_id, -ENOSPC, "no filters available");
+	zassert_true(filter_id >= 0, "negative filter number");
 	return filter_id;
 }
-
-static inline int attach_isr(const struct device *can_dev,
-			     const struct zcan_filter *filter,
-			     can_rx_callback_t isr)
+/**
+ * @brief Add a CAN filter with asserts.
+ *
+ * @param dev      Pointer to the device structure for the driver instance.
+ * @param filter   CAN filter.
+ * @param callback Receive callback function.
+ *
+ * @return CAN filter ID.
+ */
+static inline int add_rx_filter(const struct device *dev,
+				const struct zcan_filter *filter,
+				can_rx_callback_t callback)
 {
 	int filter_id;
-
-	k_sem_reset(&rx_isr_sem);
-
-	filter_id = can_attach_isr(can_dev, isr, (void *)filter, filter);
-	zassert_not_equal(filter_id, CAN_NO_FREE_FILTER,
-			  "Filter full even for a single one");
-	zassert_true((filter_id >= 0), "Negative filter number");
-
+	k_sem_reset(&rx_callback_sem);
+	filter_id = can_add_rx_filter(dev, callback, (void *)filter, filter);
+	zassert_not_equal(filter_id, -ENOSPC, "no filters available");
+	zassert_true(filter_id >= 0, "negative filter number");
 	return filter_id;
 }
-
+/**
+ * @brief Perform a send/receive test with a set of CAN ID filters and CAN frames.
+ *
+ * @param filter1 CAN filter 1
+ * @param filter2 CAN filter 2
+ * @param frame1  CAN frame 1
+ * @param frame2  CAN frame 2
+ */
 static void send_receive(const struct zcan_filter *filter1,
 			 const struct zcan_filter *filter2,
-			 const struct zcan_frame *msg1,
-			 const struct zcan_frame *msg2)
+			 const struct zcan_frame *frame1,
+			 const struct zcan_frame *frame2)
 {
-	int ret, filter_id_1, filter_id_2;
-	struct zcan_frame msg_buffer;
+	struct zcan_frame frame_buffer;
 	uint32_t mask = 0U;
-
-	zassert_not_null(can_dev, "Device not not found");
-
-	filter_id_1 = attach_msgq(can_dev, filter1);
-	send_test_msg(can_dev, msg1);
-	ret = k_msgq_get(&can_msgq, &msg_buffer, TEST_RECEIVE_TIMEOUT);
-	zassert_equal(ret, 0, "Receiving timeout");
-
+	int filter_id_1;
+	int filter_id_2;
+	int err;
+	filter_id_1 = add_rx_msgq(can_dev, filter1);
+	send_test_frame(can_dev, frame1);
+	err = k_msgq_get(&can_msgq, &frame_buffer, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, 0, "receive timeout");
 	if (filter1->id_type == CAN_STANDARD_IDENTIFIER) {
 		if (filter1->id_mask != CAN_STD_ID_MASK) {
 			mask = 0x0F;
@@ -427,326 +518,445 @@ static void send_receive(const struct zcan_filter *filter1,
 			mask = 0x0F;
 		}
 	}
-
-	check_msg(&msg_buffer, msg1, mask);
-	can_detach(can_dev, filter_id_1);
-
-	k_sem_reset(&tx_cb_sem);
-	if (msg1->id_type == CAN_STANDARD_IDENTIFIER) {
+	assert_frame_equal(&frame_buffer, frame1, mask);
+	can_remove_rx_filter(can_dev, filter_id_1);
+	k_sem_reset(&tx_callback_sem);
+	if (frame1->id_type == CAN_STANDARD_IDENTIFIER) {
 		if (filter1->id_mask == CAN_STD_ID_MASK) {
-			filter_id_1 = attach_isr(can_dev, filter1,
-						 rx_std_isr_1);
-			filter_id_2 = attach_isr(can_dev, filter2,
-						 rx_std_isr_2);
-			send_test_msg_nowait(can_dev, msg1, tx_std_isr_1);
-			send_test_msg_nowait(can_dev, msg2, tx_std_isr_2);
+			filter_id_1 = add_rx_filter(can_dev, filter1, rx_std_callback_1);
+			filter_id_2 = add_rx_filter(can_dev, filter2, rx_std_callback_2);
+			send_test_frame_nowait(can_dev, frame1, tx_std_callback_1);
+			send_test_frame_nowait(can_dev, frame2, tx_std_callback_2);
 		} else {
-			filter_id_1 = attach_isr(can_dev, filter1,
-						 rx_std_mask_isr_1);
-			filter_id_2 = attach_isr(can_dev, filter2,
-						 rx_std_mask_isr_2);
-			send_test_msg_nowait(can_dev, msg1, tx_std_isr_1);
-			send_test_msg_nowait(can_dev, msg2, tx_std_isr_2);
+			filter_id_1 = add_rx_filter(can_dev, filter1, rx_std_mask_callback_1);
+			filter_id_2 = add_rx_filter(can_dev, filter2, rx_std_mask_callback_2);
+			send_test_frame_nowait(can_dev, frame1, tx_std_callback_1);
+			send_test_frame_nowait(can_dev, frame2, tx_std_callback_2);
 		}
 	} else {
 		if (filter1->id_mask == CAN_EXT_ID_MASK) {
-			filter_id_1 = attach_isr(can_dev, filter1,
-						 rx_ext_isr_1);
-			filter_id_2 = attach_isr(can_dev, filter2,
-						 rx_ext_isr_2);
-			send_test_msg_nowait(can_dev, msg1, tx_ext_isr_1);
-			send_test_msg_nowait(can_dev, msg2, tx_ext_isr_2);
+			filter_id_1 = add_rx_filter(can_dev, filter1, rx_ext_callback_1);
+			filter_id_2 = add_rx_filter(can_dev, filter2, rx_ext_callback_2);
+			send_test_frame_nowait(can_dev, frame1, tx_ext_callback_1);
+			send_test_frame_nowait(can_dev, frame2, tx_ext_callback_2);
 		} else {
-			filter_id_1 = attach_isr(can_dev, filter1,
-						 rx_ext_mask_isr_1);
-			filter_id_2 = attach_isr(can_dev, filter2,
-						 rx_ext_mask_isr_2);
-			send_test_msg_nowait(can_dev, msg1, tx_ext_isr_1);
-			send_test_msg_nowait(can_dev, msg2, tx_ext_isr_2);
+			filter_id_1 = add_rx_filter(can_dev, filter1, rx_ext_mask_callback_1);
+			filter_id_2 = add_rx_filter(can_dev, filter2, rx_ext_mask_callback_2);
+			send_test_frame_nowait(can_dev, frame1, tx_ext_callback_1);
+			send_test_frame_nowait(can_dev, frame2, tx_ext_callback_2);
 		}
 	}
+	err = k_sem_take(&rx_callback_sem, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, 0, "receive timeout");
+	err = k_sem_take(&rx_callback_sem, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, 0, "receive timeout");
+	err = k_sem_take(&tx_callback_sem, TEST_SEND_TIMEOUT);
+	zassert_equal(err, 0, "missing TX callback");
+	err = k_sem_take(&tx_callback_sem, TEST_SEND_TIMEOUT);
+	zassert_equal(err, 0, "missing TX callback");
+	can_remove_rx_filter(can_dev, filter_id_1);
+	can_remove_rx_filter(can_dev, filter_id_2);
+}
+
+/**
+ * @brief Perform a send/receive test with a set of CAN ID filters and CAN frames, RTR and data
+ * frames.
+ *
+ * @param data_filter CAN data filter
+ * @param rtr_filter  CAN RTR filter
+ * @param data_frame  CAN data frame
+ * @param rtr_frame   CAN RTR frame
+ */
+void send_receive_rtr(const struct zcan_filter *data_filter,
+		      const struct zcan_filter *rtr_filter,
+		      const struct zcan_frame *data_frame,
+		      const struct zcan_frame *rtr_frame)
+{
+	struct zcan_frame frame;
+	int filter_id;
+	int err;
 
-	ret = k_sem_take(&rx_isr_sem, TEST_RECEIVE_TIMEOUT);
-	zassert_equal(ret, 0, "Receiving timeout");
-	ret = k_sem_take(&rx_isr_sem, TEST_RECEIVE_TIMEOUT);
-	zassert_equal(ret, 0, "Receiving timeout");
-	ret = k_sem_take(&tx_cb_sem, TEST_SEND_TIMEOUT);
-	zassert_equal(ret, 0, "Missing TX callback");
-	ret = k_sem_take(&tx_cb_sem, TEST_SEND_TIMEOUT);
-	zassert_equal(ret, 0, "Missing TX callback");
-	can_detach(can_dev, filter_id_1);
-	can_detach(can_dev, filter_id_2);
-
-	if (msg1->id_type == CAN_STANDARD_IDENTIFIER) {
-		if (filter1->id_mask == CAN_STD_ID_MASK) {
-			filter_id_1 = attach_workq(can_dev, filter1,
-						   &can_work_1, rx_std_cb_1);
-			filter_id_2 = attach_workq(can_dev, filter2,
-						   &can_work_2, rx_std_cb_2);
-		} else {
-			filter_id_1 = attach_workq(can_dev, filter1,
-						   &can_work_1,
-						   rx_std_mask_cb_1);
-			filter_id_2 = attach_workq(can_dev, filter2,
-						   &can_work_2,
-						   rx_std_mask_cb_2);
-		}
-	} else {
-		if (filter1->id_mask == CAN_EXT_ID_MASK) {
-			filter_id_1 = attach_workq(can_dev, filter1,
-						   &can_work_1, rx_ext_cb_1);
-			filter_id_2 = attach_workq(can_dev, filter2,
-						   &can_work_2, rx_ext_cb_2);
-		} else {
-			filter_id_1 = attach_workq(can_dev, filter1,
-						    &can_work_1,
-						    rx_ext_mask_cb_1);
-			filter_id_2 = attach_workq(can_dev, filter2,
-						   &can_work_2,
-						   rx_ext_mask_cb_2);
-		}
-	}
+	filter_id = add_rx_msgq(can_dev, rtr_filter);
+
+	/* Verify that RTR filter does not match data frame */
+	send_test_frame(can_dev, data_frame);
+	err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, -EAGAIN, "Data frame passed RTR filter");
+
+	/* Verify that RTR filter matches RTR frame */
+	send_test_frame(can_dev, rtr_frame);
+	err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, 0, "receive timeout");
+	assert_frame_equal(&frame, rtr_frame, 0);
 
-	send_test_msg(can_dev, msg1);
-	send_test_msg(can_dev, msg2);
-	ret = k_sem_take(&rx_cb_sem, TEST_RECEIVE_TIMEOUT);
-	zassert_equal(ret, 0, "Receiving timeout");
-	ret = k_sem_take(&rx_cb_sem, TEST_RECEIVE_TIMEOUT);
-	zassert_equal(ret, 0, "Receiving timeout");
-	can_detach(can_dev, filter_id_2);
-	can_detach(can_dev, filter_id_1);
+	can_remove_rx_filter(can_dev, filter_id);
+
+	filter_id = add_rx_msgq(can_dev, data_filter);
+
+	/* Verify that data filter does not match RTR frame */
+	send_test_frame(can_dev, rtr_frame);
+	err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, -EAGAIN, "RTR frame passed data filter");
+
+	/* Verify that data filter matches data frame */
+	send_test_frame(can_dev, data_frame);
+	err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, 0, "receive timeout");
+	assert_frame_equal(&frame, data_frame, 0);
+
+	can_remove_rx_filter(can_dev, filter_id);
 }
 
-/*
- * Set driver to loopback mode
- * The driver stays in loopback mode after that.
- * The controller can now be tested against itself
+/**
+ * @brief Test getting the CAN core clock rate.
+ */
+static void test_get_core_clock(void)
+{
+	uint32_t rate;
+	int err;
+	err = can_get_core_clock(can_dev, &rate);
+	zassert_equal(err, 0, "failed to get CAN core clock rate (err %d)", err);
+	zassert_not_equal(rate, 0, "CAN core clock rate is 0");
+}
+/**
+ * @brief CAN state change callback.
+ */
+static void state_change_callback(const struct device *dev, enum can_state state,
+				  struct can_bus_err_cnt err_cnt, void *user_data)
+{
+	ARG_UNUSED(dev);
+	ARG_UNUSED(state);
+	ARG_UNUSED(err_cnt);
+	ARG_UNUSED(user_data);
+@@ -655,226 +750,244 @@
+ * @brief Test configuring the CAN controller for loopback mode.
+ *
+ * This test case must be run before sending/receiving test cases as it allows
+ * these test cases to send/receive their own frames.
  */
 static void test_set_loopback(void)
 {
-	int ret;
-
-	ret = can_set_mode(can_dev, CAN_LOOPBACK_MODE);
-	zassert_equal(ret, 0, "Can't set loopback-mode. Err: %d", ret);
+	int err;
+	err = can_set_mode(can_dev, CAN_MODE_LOOPBACK);
+	zassert_equal(err, 0, "failed to set loopback-mode (err %d)", err);
 }
-
-/*
- * Sending a message to the wild should work because we are in loopback mode
- * and therfor ACK the frame ourselves
+/**
+ * @brief Test sending a message with no filters installed.
+ *
+ * This basic test work since the CAN controller is in loopback mode and
+ * therefore ACKs its own frame.
  */
 static void test_send_and_forget(void)
 {
-	zassert_not_null(can_dev, "Device not not found");
-
-	send_test_msg(can_dev, &test_std_msg_1);
+	send_test_frame(can_dev, &test_std_frame_1);
 }
-
-/*
- * Test very basic filter attachment
- * Test each type but only one filter at a time
+/**
+ * @brief Test adding basic filters.
+ *
+ * Test each filter type but only one filter at a time.
  */
-static void test_filter_attach(void)
+static void test_add_filter(void)
 {
 	int filter_id;
-
-	filter_id = attach_isr(can_dev, &test_std_filter_1, rx_std_isr_1);
-	can_detach(can_dev, filter_id);
-
-	filter_id = attach_isr(can_dev, &test_ext_filter_1, rx_ext_isr_1);
-	can_detach(can_dev, filter_id);
-
-	filter_id = attach_msgq(can_dev, &test_std_filter_1);
-	can_detach(can_dev, filter_id);
-
-	filter_id = attach_msgq(can_dev, &test_ext_filter_1);
-	can_detach(can_dev, filter_id);
-
-	filter_id = attach_isr(can_dev, &test_std_masked_filter_1,
-			       rx_std_mask_isr_1);
-	can_detach(can_dev, filter_id);
-
-	filter_id = attach_isr(can_dev, &test_ext_masked_filter_1,
-			       rx_ext_mask_isr_1);
-	can_detach(can_dev, filter_id);
-
-	filter_id = attach_workq(can_dev, &test_std_filter_1, &can_work_1,
-				 rx_std_cb_1);
-	can_detach(can_dev, filter_id);
-
-	filter_id = attach_workq(can_dev, &test_ext_filter_1, &can_work_2,
-				 rx_ext_cb_1);
-	can_detach(can_dev, filter_id);
+	filter_id = add_rx_filter(can_dev, &test_std_filter_1, rx_std_callback_1);
+	can_remove_rx_filter(can_dev, filter_id);
+	filter_id = add_rx_filter(can_dev, &test_ext_filter_1, rx_ext_callback_1);
+	can_remove_rx_filter(can_dev, filter_id);
+	filter_id = add_rx_msgq(can_dev, &test_std_filter_1);
+	can_remove_rx_filter(can_dev, filter_id);
+	filter_id = add_rx_msgq(can_dev, &test_ext_filter_1);
+	can_remove_rx_filter(can_dev, filter_id);
+	filter_id = add_rx_filter(can_dev, &test_std_masked_filter_1, rx_std_mask_callback_1);
+	can_remove_rx_filter(can_dev, filter_id);
+	filter_id = add_rx_filter(can_dev, &test_ext_masked_filter_1, rx_ext_mask_callback_1);
+	can_remove_rx_filter(can_dev, filter_id);
+}
+/**
+ * @brief Test adding up to and above the maximum number of RX filters.
+ *
+ * @param id_type CAN frame identifier type
+ * @param id_mask filter
+ */
+static void add_remove_max_filters(enum can_ide id_type)
+{
+	uint32_t id_mask = id_type == CAN_STANDARD_IDENTIFIER ? CAN_STD_ID_MASK : CAN_EXT_ID_MASK;
+	struct zcan_filter filter = {
+		.id_type = id_type,
+		.rtr = CAN_DATAFRAME,
+		.id = 0,
+		.rtr_mask = 1,
+		.id_mask = id_mask,
+	};
+	int filter_id;
+	int max;
+	int i;
+	max = can_get_max_filters(can_dev, id_type);
+	if (max == -ENOSYS || max == 0) {
+		/*
+		 * Skip test if max is not known or no filters of the given type
+		 * is supported.
+		 */
+		ztest_test_skip();
+	}
+	zassert_true(max > 0, "failed to get max filters (err %d)", max);
+	int filter_ids[max];
+	for (i = 0; i < max; i++) {
+		filter.id++;
+		filter_ids[i] = add_rx_msgq(can_dev, &filter);
+	}
+	filter.id++;
+	filter_id = can_add_rx_filter_msgq(can_dev, &can_msgq, &filter);
+	zassert_equal(filter_id, -ENOSPC, "added more than max filters");
+	for (i = 0; i < max; i++) {
+		can_remove_rx_filter(can_dev, filter_ids[i]);
+	}
 }
-
-/*
- * Test if a message is received wile nothing was sent.
+/**
+ * @brief Test max standard (11-bit) CAN RX filters.
  */
-static void test_receive_timeout(void)
+static void test_max_std_filters(void)
 {
-	int ret, filter_id;
-	struct zcan_frame msg;
-
-	filter_id = attach_msgq(can_dev, &test_std_filter_1);
-
-	ret = k_msgq_get(&can_msgq, &msg, TEST_RECEIVE_TIMEOUT);
-	zassert_equal(ret, -EAGAIN, "Got a message without sending it");
-
-	can_detach(can_dev, filter_id);
+	add_remove_max_filters(CAN_STANDARD_IDENTIFIER);
 }
-
-/*
- * Test if the callback function is called
+/**
+ * @brief Test max extended (29-bit) CAN RX filters.
+ */
+static void test_max_ext_filters(void)
+{
+	add_remove_max_filters(CAN_EXTENDED_IDENTIFIER);
+}
+/**
+ * @brief Test that no message is received when nothing was sent.
+ */
+static void test_receive_timeout(void)
+{
+	struct zcan_frame frame;
+	int filter_id;
+	int err;
+	filter_id = add_rx_msgq(can_dev, &test_std_filter_1);
+	err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, -EAGAIN, "received a frame without sending one");
+	can_remove_rx_filter(can_dev, filter_id);
+}
+/**
+ * @brief Test that transmit callback function is called.
  */
 static void test_send_callback(void)
 {
-	int ret;
-
-	k_sem_reset(&tx_cb_sem);
-
-	send_test_msg_nowait(can_dev, &test_std_msg_1, tx_std_isr_1);
-
-	ret = k_sem_take(&tx_cb_sem, TEST_SEND_TIMEOUT);
-	zassert_equal(ret, 0, "Missing TX callback");
+	int err;
+	k_sem_reset(&tx_callback_sem);
+	send_test_frame_nowait(can_dev, &test_std_frame_1, tx_std_callback_1);
+	err = k_sem_take(&tx_callback_sem, TEST_SEND_TIMEOUT);
+	zassert_equal(err, 0, "missing TX callback");
 }
 
-/*
- * Attach to a filter that should pass the message and send the message.
- * The massage should be received within a small timeout.
- * Standard identifier
+
+/**
+ * @brief Test send/receive with standard (11-bit) CAN IDs.
  */
-void test_send_receive_std(void)
+void test_send_receive_std_id(void)
 {
 	send_receive(&test_std_filter_1, &test_std_filter_2,
-		     &test_std_msg_1, &test_std_msg_2);
+		     &test_std_frame_1, &test_std_frame_2);
 }
-
-/*
- * Attach to a filter that should pass the message and send the message.
- * The massage should be received within a small timeout
- * Extended identifier
+/**
+ * @brief Test send/receive with extended (29-bit) CAN IDs.
  */
-void test_send_receive_ext(void)
+void test_send_receive_ext_id(void)
 {
 	send_receive(&test_ext_filter_1, &test_ext_filter_2,
-		     &test_ext_msg_1, &test_ext_msg_2);
+		     &test_ext_frame_1, &test_ext_frame_2);
 }
-
-/*
- * Attach to a filter that should pass the message and send the message.
- * The massage should be received within a small timeout.
- * The message ID is slightly different to the filter but should still
- * because of the mask settind in the filter.
- * Standard identifier
+/**
+ * @brief Test send/receive with standard (11-bit) masked CAN IDs.
  */
-void test_send_receive_std_masked(void)
+void test_send_receive_std_id_masked(void)
 {
 	send_receive(&test_std_masked_filter_1, &test_std_masked_filter_2,
-		     &test_std_msg_1, &test_std_msg_2);
+		     &test_std_frame_1, &test_std_frame_2);
 }
-
-/*
- * Attach to a filter that should pass the message and send the message.
- * The massage should be received within a small timeout.
- * The message ID is slightly different to the filter but should still
- * because of the mask settind in the filter.
- * Extended identifier
+/**
+ * @brief Test send/receive with extended (29-bit) masked CAN IDs.
  */
-void test_send_receive_ext_masked(void)
+void test_send_receive_ext_id_masked(void)
 {
 	send_receive(&test_ext_masked_filter_1, &test_ext_masked_filter_2,
-		     &test_ext_msg_1, &test_ext_msg_2);
+		     &test_ext_frame_1, &test_ext_frame_2);
 }
-
-/*
- * Attach to a filter that should pass the message and send multiple messages.
- * The massage should be received and buffered within a small timeout.
- * Extended identifier
+/**
+ * @brief Test send/receive with messages buffered in a CAN message queue.
  */
-void test_send_receive_buffer(void)
+void test_send_receive_msgq(void)
 {
-	int filter_id, i, ret;
-
-	filter_id = attach_workq(can_dev, &test_std_filter_1, &can_work_1,
-				 rx_std_cb_1);
-	k_sem_reset(&rx_cb_sem);
-
-	for (i = 0; i < CONFIG_CAN_WORKQ_FRAMES_BUF_CNT; i++) {
-		send_test_msg(can_dev, &test_std_msg_1);
+	struct k_msgq_attrs attrs;
+	struct zcan_frame frame;
+	int filter_id;
+	int nframes;
+	int err;
+	int i;
+	filter_id = add_rx_msgq(can_dev, &test_std_filter_1);
+	k_msgq_get_attrs(&can_msgq, &attrs);
+	nframes = attrs.max_msgs;
+	for (i = 0; i < nframes; i++) {
+		send_test_frame(can_dev, &test_std_frame_1);
 	}
-
-	for (i = 0; i < CONFIG_CAN_WORKQ_FRAMES_BUF_CNT; i++) {
-		ret = k_sem_take(&rx_cb_sem, TEST_RECEIVE_TIMEOUT);
-		zassert_equal(ret, 0, "Receiving timeout");
+	for (i = 0; i < nframes; i++) {
+		err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+		zassert_equal(err, 0, "receive timeout");
+		assert_frame_equal(&frame, &test_std_frame_1, 0);
 	}
-
-	for (i = 0; i < CONFIG_CAN_WORKQ_FRAMES_BUF_CNT; i++) {
-		send_test_msg(can_dev, &test_std_msg_1);
+	for (i = 0; i < nframes; i++) {
+		send_test_frame(can_dev, &test_std_frame_1);
 	}
-
-	for (i = 0; i < CONFIG_CAN_WORKQ_FRAMES_BUF_CNT; i++) {
-		ret = k_sem_take(&rx_cb_sem, TEST_RECEIVE_TIMEOUT);
-		zassert_equal(ret, 0, "Receiving timeout");
+	for (i = 0; i < nframes; i++) {
+		err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+		zassert_equal(err, 0, "receive timeout");
+		assert_frame_equal(&frame, &test_std_frame_1, 0);
 	}
-
-	can_detach(can_dev, filter_id);
+	can_remove_rx_filter(can_dev, filter_id);
 }
-
-/*
- * Attach to a filter that should not pass the message and send a message
- * with a different id.
- * The massage should not be received.
+/**
+ * @brief Test send/receive with standard (11-bit) CAN IDs and remote transmission request (RTR).
  */
-static void test_send_receive_wrong_id(void)
+void test_send_receive_std_id_rtr(void)
 {
-	int ret, filter_id;
-	struct zcan_frame msg_buffer;
-
-	filter_id = attach_msgq(can_dev, &test_std_filter_1);
-
-	send_test_msg(can_dev, &test_std_msg_2);
-
-	ret = k_msgq_get(&can_msgq, &msg_buffer, TEST_RECEIVE_TIMEOUT);
-	zassert_equal(ret, -EAGAIN,
-		      "Got a message that should not pass the filter");
+	send_receive_rtr(&test_std_filter_1, &test_std_rtr_filter_1,
+			 &test_std_frame_1, &test_std_rtr_frame_1);
+}
 
-	can_detach(can_dev, filter_id);
+/**
+ * @brief Test send/receive with extended (29-bit) CAN IDs and remote transmission request (RTR).
+ */
+void test_send_receive_ext_id_rtr(void)
+{
+	send_receive_rtr(&test_ext_filter_1, &test_ext_rtr_filter_1,
+			 &test_ext_frame_1, &test_ext_rtr_frame_1);
 }
 
-/*
- * Check if a call with dlc > CAN_MAX_DLC returns CAN_TX_EINVAL
+/**
+ * @brief Test that non-matching CAN frames do not pass a filter.
+ */
+static void test_send_receive_wrong_id(void)
+{
+	struct zcan_frame frame_buffer;
+	int filter_id;
+	int err;
+	filter_id = add_rx_msgq(can_dev, &test_std_filter_1);
+	send_test_frame(can_dev, &test_std_frame_2);
+	err = k_msgq_get(&can_msgq, &frame_buffer, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, -EAGAIN, "recevied a frame that should not pass the filter");
+	can_remove_rx_filter(can_dev, filter_id);
+}
+/**
+ * @brief Test that frames with invalid Data Length Code (DLC) are rejected.
  */
 static void test_send_invalid_dlc(void)
 {
 	struct zcan_frame frame;
-	int ret;
-
+	int err;
 	frame.dlc = CAN_MAX_DLC + 1;
-
-	ret = can_send(can_dev, &frame, TEST_SEND_TIMEOUT, tx_std_isr_1, NULL);
-	zassert_equal(ret, CAN_TX_EINVAL,
-		      "ret [%d] not equal to %d", ret, CAN_TX_EINVAL);
+	err = can_send(can_dev, &frame, TEST_SEND_TIMEOUT, NULL, NULL);
+	zassert_equal(err, -EINVAL, "sent a frame with an invalid DLC");
+}
+static void test_recover(void)
+{
+	int err;
+	/* It is not possible to provoke a bus off state, but test the API call */
+	err = can_recover(can_dev, TEST_RECOVER_TIMEOUT);
+	if (err == -ENOTSUP) {
+		ztest_test_skip();
+	}
+	zassert_equal(err, 0, "failed to recover (err %d)", err);
+}
+static void test_get_state(void)
+{
+	struct can_bus_err_cnt err_cnt;
+	enum can_state state;
+	int err;
+	err = can_get_state(can_dev, NULL, NULL);
+	zassert_equal(err, 0, "failed to get CAN state without destinations (err %d)", err);
+	err = can_get_state(can_dev, &state, NULL);
+	zassert_equal(err, 0, "failed to get CAN state (err %d)", err);
+	err = can_get_state(can_dev, NULL, &err_cnt);
+	zassert_equal(err, 0, "failed to get CAN error counters (err %d)", err);
+	err = can_get_state(can_dev, &state, &err_cnt);
+	zassert_equal(err, 0, "failed to get CAN state + error counters (err %d)", err);
+}
+static void test_filters_preserved_through_mode_change(void)
+{
+	struct zcan_frame frame;
+	int filter_id;
+	int err;
+	filter_id = add_rx_msgq(can_dev, &test_std_filter_1);
+	send_test_frame(can_dev, &test_std_frame_1);
+	err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, 0, "receive timeout");
+	assert_frame_equal(&frame, &test_std_frame_1, 0);
+	err = can_set_mode(can_dev, CAN_MODE_NORMAL);
+	zassert_equal(err, 0, "failed to set normal mode (err %d)", err);
+	err = can_set_mode(can_dev, CAN_MODE_LOOPBACK);
+	zassert_equal(err, 0, "failed to set loopback-mode (err %d)", err);
+	send_test_frame(can_dev, &test_std_frame_1);
+	err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, 0, "receive timeout");
+	assert_frame_equal(&frame, &test_std_frame_1, 0);
+	can_remove_rx_filter(can_dev, filter_id);
+}
+static void test_filters_preserved_through_bitrate_change(void)
+{
+	struct zcan_frame frame;
+	int filter_id;
+	int err;
+	filter_id = add_rx_msgq(can_dev, &test_std_filter_1);
+	send_test_frame(can_dev, &test_std_frame_1);
+	err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, 0, "receive timeout");
+	assert_frame_equal(&frame, &test_std_frame_1, 0);
+	err = can_set_bitrate(can_dev, TEST_BITRATE_2);
+	zassert_equal(err, 0, "failed to set bitrate");
+	err = can_set_bitrate(can_dev, TEST_BITRATE_1);
+	zassert_equal(err, 0, "failed to set bitrate");
+	send_test_frame(can_dev, &test_std_frame_1);
+	err = k_msgq_get(&can_msgq, &frame, TEST_RECEIVE_TIMEOUT);
+	zassert_equal(err, 0, "receive timeout");
+	assert_frame_equal(&frame, &test_std_frame_1, 0);
+	can_remove_rx_filter(can_dev, filter_id);
 }
 
 void test_main(void)
 {
 	k_sem_init(&rx_isr_sem, 0, 2);
-	k_sem_init(&rx_cb_sem, 0, INT_MAX);
 	k_sem_init(&tx_cb_sem, 0, 2);
-	can_dev = device_get_binding(CAN_DEVICE_NAME);
-	zassert_not_null(can_dev, "Device not found");
-
-	ztest_test_suite(can_driver,
-			 ztest_unit_test(test_set_loopback),
-			 ztest_unit_test(test_send_and_forget),
-			 ztest_unit_test(test_filter_attach),
-			 ztest_unit_test(test_receive_timeout),
+
+	zassert_true(device_is_ready(can_dev), "CAN device not ready");
+	k_object_access_grant(&can_msgq, k_current_get());
+	k_object_access_grant(can_dev, k_current_get());
+	/* Tests without callbacks can run in userspace */
+	ztest_test_suite(can_api_tests,
+			 ztest_user_unit_test(test_get_core_clock),
+			 ztest_unit_test(test_set_state_change_callback),
+			 ztest_user_unit_test(test_set_bitrate_too_high),
+			 ztest_user_unit_test(test_set_bitrate),
+			 ztest_user_unit_test(test_set_loopback),
+			 ztest_user_unit_test(test_send_and_forget),
+			 ztest_unit_test(test_add_filter),
+			 ztest_user_unit_test(test_max_std_filters),
+			 ztest_user_unit_test(test_max_ext_filters),
+			 ztest_user_unit_test(test_receive_timeout),
 			 ztest_unit_test(test_send_callback),
-			 ztest_unit_test(test_send_receive_std),
-			 ztest_unit_test(test_send_invalid_dlc),
-			 ztest_unit_test(test_send_receive_ext),
-			 ztest_unit_test(test_send_receive_std_masked),
-			 ztest_unit_test(test_send_receive_ext_masked),
-			 ztest_unit_test(test_send_receive_buffer),
-			 ztest_unit_test(test_send_receive_wrong_id));
-	ztest_run_test_suite(can_driver);
+			 ztest_unit_test(test_send_receive_std_id),
+			 ztest_unit_test(test_send_receive_ext_id),
+			 ztest_unit_test(test_send_receive_std_id_masked),
+			 ztest_unit_test(test_send_receive_ext_id_masked),
+			 ztest_user_unit_test(test_send_receive_msgq),
+			 ztest_user_unit_test(test_send_receive_std_id_rtr),
+			 ztest_user_unit_test(test_send_receive_ext_id_rtr),
+			 ztest_user_unit_test(test_send_invalid_dlc),
+			 ztest_unit_test(test_send_receive_wrong_id),
+			 ztest_user_unit_test(test_recover),
+			 ztest_user_unit_test(test_get_state),
+			 ztest_user_unit_test(test_filters_preserved_through_mode_change),
+			 ztest_user_unit_test(test_filters_preserved_through_bitrate_change));
+	ztest_run_test_suite(can_api_tests);
+
 }
